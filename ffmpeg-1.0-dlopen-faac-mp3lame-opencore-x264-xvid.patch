--- ffmpeg-1.0/configure.dlopen~	2012-09-28 03:37:35.000000000 +0200
+++ ffmpeg-1.0/configure	2012-10-08 14:51:56.683338438 +0200
@@ -187,6 +187,7 @@ External library support:
   --enable-libdc1394       enable IIDC-1394 grabbing using libdc1394
                            and libraw1394 [no]
   --enable-libfaac         enable AAC encoding via libfaac [no]
+  --enable-libfaac-dlopen  enable FAAC support via dlopen()'ed libfaac [no]
   --enable-libfdk-aac      enable AAC encoding via libfdk-aac [no]
   --enable-libflite        enable flite (voice synthesis) support via libflite [no]
   --enable-libfreetype     enable libfreetype [no]
@@ -195,10 +196,13 @@ External library support:
   --enable-libilbc         enable iLBC de/encoding via libilbc [no]
   --enable-libmodplug      enable ModPlug via libmodplug [no]
   --enable-libmp3lame      enable MP3 encoding via libmp3lame [no]
+  --enable-libmp3lame-dlopen enable MP3 encoding via dlopen()'ed libmp3lame [no]
   --enable-libnut          enable NUT (de)muxing via libnut,
                            native (de)muxer exists [no]
   --enable-libopencore-amrnb enable AMR-NB de/encoding via libopencore-amrnb [no]
+  --enable-libopencore-amrnb-dlopen enable AMR-NB de/encoding via dlopen()'ed libopencore-amrnb [no]
   --enable-libopencore-amrwb enable AMR-WB decoding via libopencore-amrwb [no]
+  --enable-libopencore-amrwb-dlopen enable AMR-WB decoding via dlopen()'ed libopencore-amrwb [no]
   --enable-libopencv       enable video filtering via libopencv [no]
   --enable-libopenjpeg     enable JPEG 2000 de/encoding via OpenJPEG [no]
   --enable-libopus         enable Opus decoding via libopus [no]
@@ -217,9 +221,11 @@ External library support:
                            native implementation exists [no]
   --enable-libvpx          enable VP8 de/encoding via libvpx [no]
   --enable-libx264         enable H.264 encoding via x264 [no]
+  --enable-libx264-dlopen  enable H.264 encoding via dlopen()'ed x264 [no]
   --enable-libxavs         enable AVS encoding via xavs [no]
   --enable-libxvid         enable Xvid encoding via xvidcore,
                            native MPEG-4/Xvid encoder exists [no]
+  --enable-libxvid-dlopen  enable Xvid encoding via dlopen()'ed xvidcore
   --enable-openal          enable OpenAL 1.1 capture support [no]
   --enable-openssl         enable openssl [no]
   --enable-zlib            enable zlib [autodetect]
@@ -1120,6 +1126,7 @@ CONFIG_LIST="
     libcelt
     libdc1394
     libfaac
+    libfaac_dlopen
     libfdk_aac
     libflite
     libfreetype
@@ -1128,9 +1135,12 @@ CONFIG_LIST="
     libilbc
     libmodplug
     libmp3lame
+    libmp3lame_dlopen
     libnut
     libopencore_amrnb
+    libopencore_amrnb_dlopen
     libopencore_amrwb
+    libopencore_amrwb_dlopen
     libopencv
     libopenjpeg
     libopus
@@ -1148,8 +1158,10 @@ CONFIG_LIST="
     libvorbis
     libvpx
     libx264
+    libx264_dlopen
     libxavs
     libxvid
+    libxvid_dlopen
     lsp
     mdct
     memalign_hack
@@ -3642,6 +3654,7 @@ enabled libcelt    && require libcelt ce
                         die "ERROR: libcelt must be installed and version must be >= 0.11.0."; }
 enabled libcaca    && require_pkg_config caca caca.h caca_create_canvas
 enabled libfaac    && require2 libfaac "stdint.h faac.h" faacEncGetVersion -lfaac
+enabled libfaac_dlopen && enable libfaac && add_cppflags "-I$(dirname `readlink -f $0`)/localinc"
 enabled libfdk_aac && require  libfdk_aac fdk-aac/aacenc_lib.h aacEncOpen -lfdk-aac
 flite_libs="-lflite_cmu_time_awb -lflite_cmu_us_awb -lflite_cmu_us_kal -lflite_cmu_us_kal16 -lflite_cmu_us_rms -lflite_cmu_us_slt -lflite_usenglish -lflite_cmulex -lflite"
 enabled libflite   && require2 libflite "flite/flite.h" flite_init $flite_libs
@@ -3650,9 +3663,12 @@ enabled libgsm     && require  libgsm gs
 enabled libilbc    && require  libilbc ilbc.h WebRtcIlbcfix_InitDecode -lilbc
 enabled libmodplug && require  libmodplug libmodplug/modplug.h ModPlug_Load -lmodplug
 enabled libmp3lame && require  "libmp3lame >= 3.98.3" lame/lame.h lame_set_VBR_quality -lmp3lame
+enabled libmp3lame_dlopen && enable libmp3lame && add_cppflags "-I$(dirname `readlink -f $0`)/localinc"
 enabled libnut     && require  libnut libnut.h nut_demuxer_init -lnut
 enabled libopencore_amrnb  && require libopencore_amrnb opencore-amrnb/interf_dec.h Decoder_Interface_init -lopencore-amrnb
+enabled libopencore_amrnb_dlopen && enable libopencore_amrnb && add_cppflags "-I$(dirname `readlink -f $0`)/localinc"
 enabled libopencore_amrwb  && require libopencore_amrwb opencore-amrwb/dec_if.h D_IF_init -lopencore-amrwb
+enabled libopencore_amrwb_dlopen && enable libopencore_amrwb && add_cppflags "-I$(dirname `readlink -f $0`)/localinc"
 enabled libopencv  && require_pkg_config opencv opencv/cxcore.h cvCreateImageHeader
 enabled libopenjpeg && require libopenjpeg openjpeg.h opj_version -lopenjpeg
 enabled libopus    && require_pkg_config opus opus_multistream.h opus_multistream_decoder_create
@@ -3680,8 +3696,10 @@ enabled libvpx     && {
 enabled libx264    && require  libx264 x264.h x264_encoder_encode -lx264 &&
                       { check_cpp_condition x264.h "X264_BUILD >= 118" ||
                         die "ERROR: libx264 must be installed and version must be >= 0.118."; }
+enabled libx264_dlopen && enable libx264 && add_cppflags "-I$(dirname `readlink -f $0`)/localinc"
 enabled libxavs    && require  libxavs xavs.h xavs_encoder_encode -lxavs
 enabled libxvid    && require  libxvid xvid.h xvid_global -lxvidcore
+enabled libxvid_dlopen && enable libxvid && add_cppflags "-I$(dirname `readlink -f $0`)/localinc"
 enabled openal     && { { for al_libs in "${OPENAL_LIBS}" "-lopenal" "-lOpenAL32"; do
                         check_lib 'AL/al.h' alGetError "${al_libs}" && break; done } ||
                         die "ERROR: openal not found"; } &&
@@ -4042,9 +4060,12 @@ echo "libiec61883 support       ${libiec
 echo "libilbc enabled           ${libilbc-no}"
 echo "libmodplug enabled        ${libmodplug-no}"
 echo "libmp3lame enabled        ${libmp3lame-no}"
+echo "libmp3lame dlopen() enabled ${libmp3lame_dlopen-no}"
 echo "libnut enabled            ${libnut-no}"
 echo "libopencore-amrnb support ${libopencore_amrnb-no}"
+echo "libopencore-amrnb dlopen() support ${libopencore_amrnb_dlopen-no}"
 echo "libopencore-amrwb support ${libopencore_amrwb-no}"
+echo "libopencore-amrwb dlopen() support ${libopencore_amrwb_dlopen-no}"
 echo "libopencv support         ${libopencv-no}"
 echo "libopenjpeg enabled       ${libopenjpeg-no}"
 echo "libopus enabled           ${libopus-no}"
@@ -4062,8 +4083,10 @@ echo "libvo-amrwbenc support    ${libvo_
 echo "libvorbis enabled         ${libvorbis-no}"
 echo "libvpx enabled            ${libvpx-no}"
 echo "libx264 enabled           ${libx264-no}"
+echo "libx264 dlopen() enabled    ${libx264_dlopen-no}"
 echo "libxavs enabled           ${libxavs-no}"
 echo "libxvid enabled           ${libxvid-no}"
+echo "libxvid dlopen() enabled           ${libxvid_dlopen-no}"
 echo "openal enabled            ${openal-no}"
 echo "openssl enabled           ${openssl-no}"
 echo "zlib enabled              ${zlib-no}"
--- ffmpeg-1.0/libavcodec/libfaac.c.dlopen~	2012-09-28 03:37:35.000000000 +0200
+++ ffmpeg-1.0/libavcodec/libfaac.c	2012-10-08 14:40:29.751299277 +0200
@@ -36,6 +36,90 @@
 /* libfaac has an encoder delay of 1024 samples */
 #define FAAC_DELAY_SAMPLES 1024
 
+#ifdef CONFIG_LIBFAAC_DLOPEN
+#include "dlopen.h"
+
+static int (*dl_faacEncGetDecoderSpecificInfo) (faacEncHandle hEncoder, unsigned char **ppBuffer,
+					  unsigned long *pSizeOfDecoderSpecificInfo);
+static int (*dl_faacEncSetConfiguration) (faacEncHandle hEncoder,
+				    faacEncConfigurationPtr config);
+
+static faacEncConfigurationPtr (*dl_faacEncGetCurrentConfiguration) (faacEncHandle hEncoder);
+static faacEncHandle (*dl_faacEncOpen) (unsigned long sampleRate,
+				  unsigned int numChannels,
+				  unsigned long *inputSamples,
+				  unsigned long *maxOutputBytes);
+static int (*dl_faacEncEncode) (faacEncHandle hEncoder, int32_t * inputBuffer, unsigned int samplesInput,
+			 unsigned char *outputBuffer,
+			 unsigned int bufferSize);
+static int (*dl_faacEncClose) (faacEncHandle hEncoder);
+
+#define faacEncGetDecoderSpecificInfo	dl_faacEncGetDecoderSpecificInfo
+#define faacEncSetConfiguration		dl_faacEncSetConfiguration
+#define	faacEncGetCurrentConfiguration	dl_faacEncGetCurrentConfiguration
+#define	faacEncOpen			dl_faacEncOpen
+#define	faacEncEncode			dl_faacEncEncode
+#define	faacEncClose			dl_faacEncClose
+#define	FAAC_LIB			"libfaac.so.0"
+
+static int loadLibFaac(AVCodecContext *avctx);
+static int loadLibFaac(AVCodecContext *avctx) {
+    void *libfaac = NULL;
+    const char *err = NULL;
+
+
+    libfaac = dlopen(FAAC_LIB, RTLD_LAZY);
+    if ((err = dlerror())) {
+	av_log(avctx, AV_LOG_FATAL, "%s\n%s is missing, faac support disabled\n", err, FAAC_LIB);
+	if (libfaac)
+	    dlclose(libfaac);
+	return 1;
+    }
+
+    dl_sym(faacEncGetDecoderSpecificInfo, (int (*) (faacEncHandle hEncoder,
+				    unsigned char **ppBuffer,
+		    		    unsigned long *pSizeOfDecoderSpecificInfo)),
+		    libfaac);
+
+    dl_sym(faacEncGetDecoderSpecificInfo, (int (*) (faacEncHandle hEncoder,
+				    unsigned char **ppBuffer,
+		    		    unsigned long *pSizeOfDecoderSpecificInfo)),
+	    	    libfaac);
+
+    dl_sym(faacEncSetConfiguration, (int (*) (faacEncHandle hEncoder,
+		    		    faacEncConfigurationPtr config)),
+	    	    libfaac);
+
+    dl_sym(faacEncGetCurrentConfiguration, (faacEncConfigurationPtr (*) (faacEncHandle hEncoder)),
+	    	    libfaac);
+
+    dl_sym(faacEncOpen, (faacEncHandle (*) (unsigned long sampleRate,
+		    		    unsigned int numChannels,
+		    		    unsigned long *inputSamples,
+		    		    unsigned long *maxOutputBytes)),
+	    	    libfaac);
+
+    dl_sym(faacEncEncode, (int (*) (faacEncHandle hEncoder,
+				    int32_t * inputBuffer,
+				    unsigned int samplesInput,
+		    		    unsigned char *outputBuffer,
+		    		    unsigned int bufferSize)),
+	    	    libfaac);
+
+    dl_sym(faacEncClose, (int (*) (faacEncHandle hEncoder)),
+	    	    libfaac);
+
+    return 0;
+
+error:
+    av_log(avctx, AV_LOG_FATAL, "libfaac: Missing symbols in %s: %s "
+	    "faac support disabled\n", FAAC_LIB, err);
+    dlclose(libfaac);
+    return 1;
+
+}
+#endif
+
 typedef struct FaacAudioContext {
     faacEncHandle faac_handle;
     AudioFrameQueue afq;
@@ -69,6 +153,12 @@ static av_cold int Faac_encode_init(AVCo
     FaacAudioContext *s = avctx->priv_data;
     faacEncConfigurationPtr faac_cfg;
     unsigned long samples_input, max_bytes_output;
+
+#ifdef CONFIG_LIBFAAC_DLOPEN
+    if (loadLibFaac(avctx))
+	return -1;
+#endif
+
     int ret;
 
     /* number of channels */
--- ffmpeg-1.0/libavcodec/libmp3lame.c.dlopen~	2012-09-28 03:37:35.000000000 +0200
+++ ffmpeg-1.0/libavcodec/libmp3lame.c	2012-10-08 14:40:29.752299278 +0200
@@ -37,6 +37,135 @@
 #include "mpegaudio.h"
 #include "mpegaudiodecheader.h"
 
+#ifdef CONFIG_LIBMP3LAME_DLOPEN
+#include "dlopen.h"
+
+static lame_global_flags* (*dl_lame_init) (void);
+
+static int  (*dl_lame_close) (lame_global_flags *);
+
+static int (*dl_lame_encode_flush) (lame_global_flags *  gfp, unsigned char* mp3buf, int size);
+
+static int (*dl_lame_encode_buffer) (lame_global_flags*  gfp, const short int buffer_l [], const short int buffer_r [], const int nsamples, unsigned char* mp3buf, const int mp3buf_size );
+
+static int (*dl_lame_encode_buffer_interleaved) (lame_global_flags*  gfp, short int pcm[], int num_samples, unsigned char* mp3buf, int mp3buf_size );
+
+static int (*dl_lame_encode_buffer_int) (lame_global_flags* gfp, const int buffer_l [], const int buffer_r [], const int nsamples, unsigned char* mp3buf, const int mp3buf_size );
+
+static int (*dl_lame_encode_buffer_float) (lame_global_flags* gfp, const float buffer_l [], const float buffer_r [], const int nsamples, unsigned char* mp3buf, const int mp3buf_size );
+
+static int (*dl_lame_get_encoder_delay) (lame_global_flags* gfp );
+
+static int (*dl_lame_set_in_samplerate) (lame_global_flags *, int);
+
+static int (*dl_lame_set_num_channels) (lame_global_flags *, int);
+
+static int (*dl_lame_set_quality) (lame_global_flags *, int);
+static int (*dl_lame_set_mode) (lame_global_flags *, MPEG_mode);
+
+static int (*dl_lame_set_out_samplerate) (lame_global_flags *, int);
+
+static int (*dl_lame_set_brate) (lame_global_flags *, int);
+
+static int (*dl_lame_set_VBR) (lame_global_flags *, vbr_mode);
+
+static int (*dl_lame_set_VBR_quality) (lame_global_flags *, float);
+
+static int (*dl_lame_set_bWriteVbrTag) (lame_global_flags *, int);
+
+static int (*dl_lame_set_disable_reservoir) (lame_global_flags *, int);
+
+static int (*dl_lame_init_params) (lame_global_flags *);
+
+static int (*dl_lame_get_framesize) (const lame_global_flags *);
+
+#define lame_init			dl_lame_init
+#define lame_close			dl_lame_close
+#define lame_encode_flush		dl_lame_encode_flush
+#define lame_encode_buffer		dl_lame_encode_buffer
+#define lame_encode_buffer_interleaved	dl_lame_encode_buffer_interleaved
+#define lame_encode_buffer_int		dl_lame_encode_buffer_int
+#define lame_encode_buffer_float	dl_lame_encode_buffer_float
+#define lame_get_encoder_delay		dl_lame_get_encoder_delay
+#define lame_set_in_samplerate		dl_lame_set_in_samplerate
+#define lame_set_num_channels		dl_lame_set_num_channels
+#define lame_set_quality		dl_lame_set_quality
+#define lame_set_mode			dl_lame_set_mode
+#define lame_set_out_samplerate		dl_lame_set_out_samplerate
+#define lame_set_brate			dl_lame_set_brate
+#define lame_set_VBR			dl_lame_set_VBR
+#define lame_set_VBR_quality		dl_lame_set_VBR_quality
+#define lame_set_bWriteVbrTag		dl_lame_set_bWriteVbrTag
+#define lame_set_disable_reservoir	dl_lame_set_disable_reservoir
+#define lame_init_params		dl_lame_init_params
+#define lame_get_framesize		dl_lame_get_framesize
+#define	MP3LAME_LIB			"libmp3lame.so.0"
+
+static int loadLibMp3Lame(AVCodecContext *avctx);
+static int loadLibMp3Lame(AVCodecContext *avctx) {
+    void *libmp3lame = NULL;
+    const char *err = NULL;
+
+
+    libmp3lame = dlopen(MP3LAME_LIB, RTLD_LAZY);
+    if ((err = dlerror())) {
+	av_log(avctx, AV_LOG_FATAL, "%s\n%s is missing, libmp3lame support disabled\n", err, MP3LAME_LIB);
+	if (libmp3lame)
+	    dlclose(libmp3lame);
+	return 1;
+    }
+
+    dl_sym(lame_init, (lame_global_flags* (*) (void)), libmp3lame);
+
+    dl_sym(lame_close, (int (*) (lame_global_flags*)), libmp3lame);
+
+    dl_sym(lame_encode_flush, (int (*) (lame_global_flags* gfp, unsigned char* mp3buf, int size)), libmp3lame);
+
+    dl_sym(lame_encode_buffer, (int (*) (lame_global_flags* gfp, const short int buffer_l [], const short int buffer_r [], const int nsamples, unsigned char* mp3buf, const int mp3buf_size)), libmp3lame);
+
+    dl_sym(lame_encode_buffer_interleaved, (int (*) (lame_global_flags* gfp, short int pcm[], int num_samples, unsigned char* mp3buf, int mp3buf_size)), libmp3lame);
+
+    dl_sym(lame_encode_buffer_int, (int (*) (lame_global_flags* gfp, const int buffer_l [], const int buffer_r [], const int nsamples, unsigned char* mp3buf, const int mp3buf_size)), libmp3lame);
+
+    dl_sym(lame_encode_buffer_float, (int (*) (lame_global_flags* gfp, const float buffer_l [], const float buffer_r [], const int nsamples, unsigned char* mp3buf, const int mp3buf_size)), libmp3lame);
+
+    dl_sym(lame_get_encoder_delay, (int (*) (lame_global_flags* gfp)), libmp3lame);
+
+    dl_sym(lame_set_in_samplerate, (int (*) (lame_global_flags *, int)), libmp3lame);
+
+    dl_sym(lame_set_num_channels, (int (*) (lame_global_flags *, int)), libmp3lame);
+
+    dl_sym(lame_set_quality, (int (*) (lame_global_flags *, int)), libmp3lame);
+
+    dl_sym(lame_set_mode, (int (*) (lame_global_flags *, MPEG_mode)), libmp3lame);
+
+    dl_sym(lame_set_out_samplerate, (int (*) (lame_global_flags *, int)), libmp3lame);
+
+    dl_sym(lame_set_brate, (int (*) (lame_global_flags *, int)), libmp3lame);
+
+    dl_sym(lame_set_VBR, (int (*) (lame_global_flags *, vbr_mode)), libmp3lame);
+
+    dl_sym(lame_set_VBR_quality, (int (*) (lame_global_flags *, float)), libmp3lame);
+
+    dl_sym(lame_set_bWriteVbrTag, (int (*) (lame_global_flags *, int)), libmp3lame);
+
+    dl_sym(lame_set_disable_reservoir, (int (*) (lame_global_flags *, int)), libmp3lame);
+
+    dl_sym(lame_init_params, (int (*) (lame_global_flags *)), libmp3lame);
+
+    dl_sym(lame_get_framesize, (int (*) (const lame_global_flags *)), libmp3lame);
+
+    return 0;
+
+error:
+    av_log(avctx, AV_LOG_FATAL, "libmp3lame: Missing symbols in %s: %s "
+	    "mp3lame support disabled\n", MP3LAME_LIB, err);
+    dlclose(libmp3lame);
+    return 1;
+
+}
+#endif
+
 #define BUFFER_SIZE (7200 + 2 * MPA_FRAME_SIZE + MPA_FRAME_SIZE / 4+1000) // FIXME: Buffer size to small? Adding 1000 to make up for it.
 
 typedef struct LAMEContext {
@@ -72,6 +201,11 @@ static av_cold int mp3lame_encode_init(A
     LAMEContext *s = avctx->priv_data;
     int ret;
 
+#ifdef CONFIG_LIBMP3LAME_DLOPEN
+    if (loadLibMp3Lame(avctx))
+	return -1;
+#endif
+
     s->avctx = avctx;
 
     /* initialize LAME and get defaults */
--- ffmpeg-1.0/libavcodec/libopencore-amr.c.dlopen~	2012-09-28 03:37:35.000000000 +0200
+++ ffmpeg-1.0/libavcodec/libopencore-amr.c	2012-10-08 14:40:29.752299278 +0200
@@ -44,6 +44,59 @@ static void amr_decode_fix_avctx(AVCodec
 #include <opencore-amrnb/interf_dec.h>
 #include <opencore-amrnb/interf_enc.h>
 
+#ifdef CONFIG_LIBOPENCORE_AMRNB_DLOPEN
+#include "dlopen.h"
+static void* (*dl_Decoder_Interface_init) (void);
+static void (*dl_Decoder_Interface_exit) (void* state);
+static void (*dl_Decoder_Interface_Decode) (void* state, const unsigned char* in, short* out, int bfi);
+static void* (*dl_Encoder_Interface_init) (int dtx);
+static void (*dl_Encoder_Interface_exit) (void* state);
+static int (*dl_Encoder_Interface_Encode) (void* state, enum Mode mode, const short* speech, unsigned char* out, int forceSpeech);
+
+#define	Decoder_Interface_init		dl_Decoder_Interface_init
+#define	Decoder_Interface_exit		dl_Decoder_Interface_exit
+#define Decoder_Interface_Decode	dl_Decoder_Interface_Decode
+#define Encoder_Interface_init		dl_Encoder_Interface_init
+#define Encoder_Interface_exit		dl_Encoder_Interface_exit
+#define Encoder_Interface_Encode	dl_Encoder_Interface_Encode
+#define	AMRNB_LIB			"libopencore-amrnb.so.0"
+
+static int loadLibAMRNB(AVCodecContext *avctx);
+static int loadLibAMRNB(AVCodecContext *avctx) {
+    void *libamrnb = NULL;
+    const char *err = NULL;
+
+    libamrnb = dlopen(AMRNB_LIB, RTLD_LAZY);
+    if ((err = dlerror())) {
+	av_log(avctx, AV_LOG_FATAL, "%s\n%s is missing, opencore-amrnb support will be disabled\n", err, AMRNB_LIB);
+	if (libamrnb)
+	    dlclose(libamrnb);
+	return 1;
+    }
+
+
+    dl_sym(Decoder_Interface_init, (void (*)), libamrnb);
+
+    dl_sym(Decoder_Interface_exit, (void (*) (void* state)), libamrnb);
+
+    dl_sym(Decoder_Interface_Decode, (void (*) (void* state, const unsigned char* in, short* out, int bfi)), libamrnb);
+
+    dl_sym(Encoder_Interface_init, (void* (*) (int dtx)), libamrnb);
+
+    dl_sym(Encoder_Interface_exit, (void (*) (void* state)), libamrnb);
+
+    dl_sym(Encoder_Interface_Encode, (int (*) (void* state, enum Mode mode, const short* speech, unsigned char* out, int forceSpeech)), libamrnb);
+
+    return 0;
+
+error:
+    av_log(avctx, AV_LOG_FATAL, "opencore-amrnb: Missing symbols in %s: %s\n"
+	    "opencore-amrnb support disabled\n", AMRNB_LIB, err);
+    dlclose(libamrnb);
+    return 1;
+}
+#endif
+
 /* Common code for fixed and float version*/
 typedef struct AMR_bitrates {
     int       rate;
@@ -188,6 +241,11 @@ static av_cold int amr_nb_encode_init(AV
 {
     AMRContext *s = avctx->priv_data;
 
+#ifdef CONFIG_LIBOPENCORE_AMRNB_DLOPEN
+    if (loadLibAMRNB(avctx))
+	return -1;
+#endif
+
     if (avctx->sample_rate != 8000) {
         av_log(avctx, AV_LOG_ERROR, "Only 8000Hz sample rate supported\n");
         return AVERROR(ENOSYS);
@@ -310,6 +368,46 @@ AVCodec ff_libopencore_amrnb_encoder = {
 #include <opencore-amrwb/dec_if.h>
 #include <opencore-amrwb/if_rom.h>
 
+#ifdef CONFIG_LIBOPENCORE_AMRWB_DLOPEN
+#include "dlopen.h"
+
+static void* (*dl_D_IF_init) (void);
+static void (*dl_D_IF_decode) (void* state, const unsigned char* bits, short* synth, int bfi);
+static void (*dl_D_IF_exit) (void* state);
+
+#define	D_IF_init			dl_D_IF_init
+#define	D_IF_decode			dl_D_IF_decode
+#define D_IF_exit			dl_D_IF_exit
+#define	AMRWB_LIB			"libopencore-amrwb.so.0"
+
+static int loadLibAMRWB(AVCodecContext *avctx) {
+    void *libamrwb = NULL;
+    const char *err = NULL;
+
+    libamrwb = dlopen(AMRWB_LIB, RTLD_LAZY);
+    if ((err = dlerror())) {
+	av_log(avctx, AV_LOG_FATAL, "%s\n%s is missing, opencore-amrwb support will be disabled\n", err, AMRWB_LIB);
+	if (libamrwb)
+	    dlclose(libamrwb);
+	return 1;
+    }
+
+    dl_sym(D_IF_init, (void (*)), libamrwb);
+
+    dl_sym(D_IF_decode, (void (*) (void* state, const unsigned char* bits, short* synth, int bfi)), libamrwb);
+
+    dl_sym(D_IF_exit, (void (*) (void* state)), libamrwb);
+
+    return 0;
+
+error:
+    av_log(avctx, AV_LOG_FATAL, "opencore-amrwb: Missing symbols in %s: %s\n"
+	    "opencore-amrwb support disabled\n", AMRWB_LIB, err);
+    dlclose(libamrwb);
+    return 1;
+}
+#endif
+
 typedef struct AMRWBContext {
     AVFrame frame;
     void  *state;
@@ -319,6 +417,11 @@ static av_cold int amr_wb_decode_init(AV
 {
     AMRWBContext *s = avctx->priv_data;
 
+#ifdef CONFIG_LIBOPENCORE_AMRWB_DLOPEN
+    if (loadLibAMRWB(avctx))
+	return -1;
+#endif
+
     s->state        = D_IF_init();
 
     amr_decode_fix_avctx(avctx);
--- ffmpeg-1.0/libavcodec/libx264.c.dlopen~	2012-09-28 03:37:35.000000000 +0200
+++ ffmpeg-1.0/libavcodec/libx264.c	2012-10-08 14:40:29.752299278 +0200
@@ -32,6 +32,98 @@
 #include <stdlib.h>
 #include <string.h>
 
+#ifdef CONFIG_LIBX264_DLOPEN
+#include "dlopen.h"
+
+static void (*dl_x264_picture_init) (x264_picture_t *);
+static int  (*dl_x264_encoder_encode) (x264_t *, x264_nal_t **, int *, x264_picture_t *, x264_picture_t *);
+static int  (*dl_x264_encoder_delayed_frames) (x264_t *);
+static x264_t* (*dl_x264_encoder_open) ( x264_param_t * );
+static int  (*dl_x264_encoder_reconfig) ( x264_t *, x264_param_t * );
+static void (*dl_x264_encoder_close) (x264_t *);
+static void (*dl_x264_param_default) (x264_param_t *);
+static int  (*dl_x264_param_parse) (x264_param_t *, const char *name, const char *value );
+static int  (*dl_x264_param_default_preset) (x264_param_t *, const char *preset, const char *tune);
+static int  (*dl_x264_param_apply_profile) (x264_param_t *, const char *profile);
+static void (*dl_x264_param_apply_fastfirstpass) (x264_param_t *);
+static int  (*dl_x264_encoder_headers) (x264_t *, x264_nal_t **, int *);
+#define x264_picture_init		dl_x264_picture_init
+#define x264_encoder_encode		dl_x264_encoder_encode
+#define	x264_encoder_delayed_frames	dl_x264_encoder_delayed_frames
+#undef x264_encoder_open
+#define x264_encoder_open		dl_x264_encoder_open
+#define x264_encoder_reconfig		dl_x264_encoder_reconfig
+#define x264_encoder_close		dl_x264_encoder_close
+#define	x264_param_default		dl_x264_param_default
+#define x264_param_apply_profile	dl_x264_param_apply_profile
+#define x264_param_apply_fastfirstpass	dl_x264_param_apply_fastfirstpass
+#define	x264_param_parse		dl_x264_param_parse
+#define x264_param_default_preset	dl_x264_param_default_preset
+#define x264_encoder_headers		dl_x264_encoder_headers
+
+#define	X264_BUILD_str num2str(X264_BUILD)
+#define	X264_LIB "libx264.so." X264_BUILD_str
+#define	x264_encoder_open_str "x264_encoder_open_" X264_BUILD_str
+
+int dl_x264_bit_depth;
+#define	x264_bit_depth dl_x264_bit_depth
+
+static int loadLibX264(AVCodecContext *avctx);
+static int loadLibX264(AVCodecContext *avctx) {
+    void *libx264 = NULL;
+    const char *err = NULL;
+    int *ptr;
+
+    libx264 = dlopen(X264_LIB, RTLD_LAZY);
+    if ((err = dlerror())) {
+	av_log(avctx, AV_LOG_FATAL, "%s\n%s is missing, x264 support will be disabled\n", err, X264_LIB);
+	if (libx264)
+	    dlclose(libx264);
+	return 1;
+    }
+
+
+    dl_sym(x264_picture_init, (void (*) (x264_picture_t *)), libx264);
+
+    dl_sym(x264_encoder_encode, (int (*) (x264_t *, x264_nal_t **, int *, x264_picture_t *, x264_picture_t *)), libx264);
+
+    dl_sym(x264_encoder_delayed_frames, (int (*) (x264_t *)), libx264);
+
+    dl_x264_encoder_open =(x264_t* (*) (x264_param_t *)) dlsym(libx264, x264_encoder_open_str);
+    if ((err = dlerror()))
+	    goto error;
+
+    dl_sym(x264_encoder_reconfig, (int (*) (x264_t *, x264_param_t * )), libx264);
+
+    dl_sym(x264_encoder_close, (void (*) (x264_t *)), libx264);
+
+    dl_sym(x264_param_default, (void (*) (x264_param_t *)), libx264);
+
+    dl_sym(x264_param_apply_fastfirstpass, (void (*) (x264_param_t *)), libx264);
+
+    dl_sym(x264_param_parse, (int (*) (x264_param_t *, const char *name, const char *value )), libx264);
+
+    dl_sym(x264_param_default_preset, (int (*) (x264_param_t *, const char *preset, const char *tune)), libx264);
+
+    dl_sym(x264_param_apply_profile, (int (*) (x264_param_t *, const char *profile)), libx264);
+
+    dl_sym(x264_param_apply_fastfirstpass, (void (*) (x264_param_t *)), libx264);
+
+    dl_sym(x264_encoder_headers, (int (*) (x264_t *, x264_nal_t **, int *)), libx264);
+
+    ptr = (int *) dlsym(libx264, "x264_bit_depth");
+    dl_x264_bit_depth = *ptr;
+
+    return 0;
+
+error:
+    av_log(avctx, AV_LOG_FATAL, "libx264: Missing symbols in %s: %s\n"
+	    "x264 support disabled\n", X264_LIB, err);
+    dlclose(libx264);
+    return 1;
+}
+#endif
+
 typedef struct X264Context {
     AVClass        *class;
     x264_param_t    params;
@@ -281,6 +373,11 @@ static av_cold int X264_init(AVCodecCont
     X264Context *x4 = avctx->priv_data;
     int sw,sh;
 
+#ifdef CONFIG_LIBX264_DLOPEN
+    if (loadLibX264(avctx))
+	return -1;
+#endif
+
     x264_param_default(&x4->params);
 
     x4->params.b_deblocking_filter         = avctx->flags & CODEC_FLAG_LOOP_FILTER;
--- ffmpeg-1.0/libavcodec/libxvid.c.dlopen~	2012-09-28 03:37:35.000000000 +0200
+++ ffmpeg-1.0/libavcodec/libxvid.c	2012-10-08 14:40:29.752299278 +0200
@@ -36,6 +36,57 @@
 #include "libxvid.h"
 #include "mpegvideo.h"
 
+#ifdef CONFIG_LIBXVID_DLOPEN
+#include "dlopen.h"
+
+static int (*dl_xvid_encore) (void *handle, int opt, void *param1, void *param2);
+static int (*dl_xvid_global) (void *handle, int opt, void *param1, void *param2);
+static int (*dl_xvid_plugin_single) (void *handle, int opt, void *param1, void *param2);
+static int (*dl_xvid_plugin_lumimasking) (void *handle, int opt, void *param1, void *param2);
+static int (*dl_xvid_plugin_2pass2) (void *handle, int opt, void *param1, void *param2);
+
+#define	xvid_encore		dl_xvid_encore
+#define	xvid_global		dl_xvid_global
+#define	xvid_plugin_single	dl_xvid_plugin_single
+#define xvid_plugin_lumimasking	dl_xvid_plugin_lumimasking
+#define xvid_plugin_2pass2	dl_xvid_plugin_2pass2
+#define	XVID_LIB		"libxvidcore.so.4"
+
+static int loadLibXVID(AVCodecContext *avctx);
+static int loadLibXVID(AVCodecContext *avctx) {
+    void *libxvid = NULL;
+    const char *err = NULL;
+
+    libxvid = dlopen(XVID_LIB, RTLD_LAZY);
+    if ((err = dlerror())) {
+	av_log(avctx, AV_LOG_FATAL, "%s\n%s is missing, libxvid support will be disabled\n", err, XVID_LIB);
+
+	if (libxvid)
+	    dlclose(libxvid);
+	return 1;
+    }
+
+  dl_sym(xvid_encore, (int (*) (void *handle, int opt, void *param1, void *param2)), libxvid);
+
+  dl_sym(xvid_global, (int (*) (void *handle, int opt, void *param1, void *param2)), libxvid);
+
+  dl_sym(xvid_plugin_single, (int (*) (void *handle, int opt, void *param1, void *param2)), libxvid);
+
+  dl_sym(xvid_plugin_lumimasking, (int (*) (void *handle, int opt, void *param1, void *param2)), libxvid);
+
+  dl_sym(xvid_plugin_2pass2, (int (*) (void *handle, int opt, void *param1, void *param2)), libxvid);
+
+  return 0;
+
+error:
+  av_log(avctx, AV_LOG_FATAL, "libxvid: Missing symbols in %s: %s "
+	    "libxvid support disabled\n", XVID_LIB, err);
+  dlclose(libxvid);
+
+  return 1;
+}
+#endif
+
 /**
  * Buffer management macros.
  */
@@ -364,6 +415,11 @@ static av_cold int xvid_encode_init(AVCo
     xvid_enc_create_t xvid_enc_create = { 0 };
     xvid_enc_plugin_t plugins[7];
 
+#ifdef CONFIG_LIBXVID_DLOPEN
+    if (loadLibXVID(avctx))
+	return -1;
+#endif
+
     /* Bring in VOP flags from ffmpeg command-line */
     x->vop_flags = XVID_VOP_HALFPEL; /* Bare minimum quality */
     if( xvid_flags & CODEC_FLAG_4MV )
--- ffmpeg-1.0/libavcodec/libxvid_rc.c.dlopen~	2012-09-28 03:37:35.000000000 +0200
+++ ffmpeg-1.0/libavcodec/libxvid_rc.c	2012-10-08 14:40:29.752299278 +0200
@@ -29,6 +29,41 @@
 //#include "dsputil.h"
 #include "mpegvideo.h"
 
+#ifdef CONFIG_LIBXVID_DLOPEN
+#include "dlopen.h"
+
+static int (*dl_xvid_plugin_2pass2) (void *handle, int opt, void *param1, void *param2);
+
+#define xvid_plugin_2pass2	dl_xvid_plugin_2pass2
+#define	XVID_LIB		"libxvidcore.so.4"
+
+static int loadLibXVID(AVCodecContext *avctx);
+static int loadLibXVID(AVCodecContext *avctx) {
+    void *libxvid = NULL;
+    const char *err = NULL;
+
+    libxvid = dlopen(XVID_LIB, RTLD_LAZY);
+    if ((err = dlerror())) {
+	av_log(avctx, AV_LOG_FATAL, "%s\n%s is missing, libxvid support will be disabled\n", err, XVID_LIB);
+
+	if (libxvid)
+	    dlclose(libxvid);
+	return 1;
+    }
+
+  dl_sym(xvid_plugin_2pass2, (int (*) (void *handle, int opt, void *param1, void *param2)), libxvid);
+
+  return 0;
+
+error:
+  av_log(avctx, AV_LOG_FATAL, "libxvid: Missing symbols in %s: %s "
+	    "libxvid support disabled\n", XVID_LIB, err);
+  dlclose(libxvid);
+
+  return 1;
+}
+#endif
+
 #undef NDEBUG
 #include <assert.h>
 
@@ -38,6 +73,11 @@ int ff_xvid_rate_control_init(MpegEncCon
     xvid_plg_create_t xvid_plg_create = { 0 };
     xvid_plugin_2pass2_t xvid_2pass2  = { 0 };
 
+#ifdef CONFIG_LIBXVID_DLOPEN
+    if (loadLibXVID(s->avctx))
+	return -1;
+#endif
+
     fd=av_tempfile("xvidrc.", &tmp_name, 0, s->avctx);
     if (fd == -1) {
         av_log(NULL, AV_LOG_ERROR, "Can't create temporary pass2 file.\n");
--- ffmpeg-1.0/localinc/dlopen.h.dlopen~	2012-10-08 14:40:29.802299272 +0200
+++ ffmpeg-1.0/localinc/dlopen.h	2012-10-08 14:40:29.809299279 +0200
@@ -0,0 +1,12 @@
+#ifndef LOCALINC_DLOPEN_H
+#define LOCALINC_DLOPEN_H
+#include <dlfcn.h>
+#define num2str(x) str(x)
+#define str(x) #x
+
+#define dl_sym(func, args, lib) \
+	dl_##func = args dlsym(lib, #func); \
+	if ((err = dlerror())) \
+		goto error;
+
+#endif
--- ffmpeg-1.0/localinc/faaccfg.h.dlopen~	2012-10-08 14:40:29.809299279 +0200
+++ ffmpeg-1.0/localinc/faaccfg.h	2012-10-08 14:40:29.809299279 +0200
@@ -0,0 +1,122 @@
+/*
+ * FAAC - Freeware Advanced Audio Coder
+ * Copyright (C) 2001 Menno Bakker
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * $Id: faaccfg.h,v 1.3 2004/07/04 12:12:05 corrados Exp $
+ */
+
+#ifndef _FAACCFG_H_
+#define _FAACCFG_H_
+
+#define FAAC_CFG_VERSION 104
+
+/* MPEG ID's */
+#define MPEG2 1
+#define MPEG4 0
+
+/* AAC object types */
+#define MAIN 1
+#define LOW  2
+#define SSR  3
+#define LTP  4
+
+/* Input Formats */
+#define FAAC_INPUT_NULL    0
+#define FAAC_INPUT_16BIT   1
+#define FAAC_INPUT_24BIT   2
+#define FAAC_INPUT_32BIT   3
+#define FAAC_INPUT_FLOAT   4
+
+#define SHORTCTL_NORMAL    0
+#define SHORTCTL_NOSHORT   1
+#define SHORTCTL_NOLONG    2
+
+#pragma pack(push, 1)
+typedef struct faacEncConfiguration
+{
+    /* config version */
+    int version;
+
+    /* library version */
+    char *name;
+
+    /* copyright string */
+    char *copyright;
+
+    /* MPEG version, 2 or 4 */
+    unsigned int mpegVersion;
+
+    /* AAC object type */
+    unsigned int aacObjectType;
+
+    /* Allow mid/side coding */
+    unsigned int allowMidside;
+
+    /* Use one of the channels as LFE channel */
+    unsigned int useLfe;
+
+    /* Use Temporal Noise Shaping */
+    unsigned int useTns;
+
+    /* bitrate / channel of AAC file */
+    unsigned long bitRate;
+
+    /* AAC file frequency bandwidth */
+    unsigned int bandWidth;
+
+    /* Quantizer quality */
+    unsigned long quantqual;
+
+    /* Bitstream output format (0 = Raw; 1 = ADTS) */
+    unsigned int outputFormat;
+
+    /* psychoacoustic model list */
+    psymodellist_t *psymodellist;
+
+    /* selected index in psymodellist */
+    unsigned int psymodelidx;
+
+    /*
+		PCM Sample Input Format
+		0	FAAC_INPUT_NULL			invalid, signifies a misconfigured config
+		1	FAAC_INPUT_16BIT		native endian 16bit
+		2	FAAC_INPUT_24BIT		native endian 24bit in 24 bits		(not implemented)
+		3	FAAC_INPUT_32BIT		native endian 24bit in 32 bits		(DEFAULT)
+		4	FAAC_INPUT_FLOAT		32bit floating point
+    */
+    unsigned int inputFormat;
+
+    /* block type enforcing (SHORTCTL_NORMAL/SHORTCTL_NOSHORT/SHORTCTL_NOLONG) */
+    int shortctl;
+	
+	/*
+		Channel Remapping
+
+		Default			0, 1, 2, 3 ... 63  (64 is MAX_CHANNELS in coder.h)
+
+		WAVE 4.0		2, 0, 1, 3
+		WAVE 5.0		2, 0, 1, 3, 4
+		WAVE 5.1		2, 0, 1, 4, 5, 3
+		AIFF 5.1		2, 0, 3, 1, 4, 5 
+	*/
+	int channel_map[64];	
+
+} faacEncConfiguration, *faacEncConfigurationPtr;
+
+#pragma pack(pop)
+
+#endif /* _FAACCFG_H_ */
--- ffmpeg-1.0/localinc/faac.h.dlopen~	2012-10-08 14:40:29.809299279 +0200
+++ ffmpeg-1.0/localinc/faac.h	2012-10-08 14:40:29.809299279 +0200
@@ -0,0 +1,99 @@
+/*
+ * FAAC - Freeware Advanced Audio Coder
+ * Copyright (C) 2001 Menno Bakker
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * $Id: faac.h,v 1.36 2009/01/25 18:50:32 menno Exp $
+ */
+
+#ifndef _FAAC_H_
+#define _FAAC_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#if defined(_WIN32) && !defined(__MINGW32__)
+# ifndef FAACAPI
+#  define FAACAPI __stdcall
+# endif
+#else
+# ifndef FAACAPI
+#  define FAACAPI
+# endif
+#endif
+
+#pragma pack(push, 1)
+
+typedef struct {
+  void *ptr;
+  char *name;
+}
+psymodellist_t;
+
+#include "faaccfg.h"
+
+
+typedef void *faacEncHandle;
+
+#ifndef HAVE_INT32_T
+typedef signed int int32_t;
+#endif
+
+/*
+	Allows an application to get FAAC version info. This is intended
+	purely for informative purposes.
+
+	Returns FAAC_CFG_VERSION.
+*/
+int FAACAPI faacEncGetVersion(char **faac_id_string,
+			      char **faac_copyright_string);
+
+
+faacEncConfigurationPtr FAACAPI
+  faacEncGetCurrentConfiguration(faacEncHandle hEncoder);
+
+
+int FAACAPI faacEncSetConfiguration(faacEncHandle hEncoder,
+				    faacEncConfigurationPtr config);
+
+
+faacEncHandle FAACAPI faacEncOpen(unsigned long sampleRate,
+				  unsigned int numChannels,
+				  unsigned long *inputSamples,
+				  unsigned long *maxOutputBytes);
+
+
+int FAACAPI faacEncGetDecoderSpecificInfo(faacEncHandle hEncoder, unsigned char **ppBuffer,
+					  unsigned long *pSizeOfDecoderSpecificInfo);
+
+
+int FAACAPI faacEncEncode(faacEncHandle hEncoder, int32_t * inputBuffer, unsigned int samplesInput,
+			 unsigned char *outputBuffer,
+			 unsigned int bufferSize);
+
+
+int FAACAPI faacEncClose(faacEncHandle hEncoder);
+
+
+
+#pragma pack(pop)
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* _FAAC_H_ */
--- ffmpeg-1.0/localinc/lame/lame.h.dlopen~	2012-10-08 14:40:29.809299279 +0200
+++ ffmpeg-1.0/localinc/lame/lame.h	2012-10-08 14:40:29.809299279 +0200
@@ -0,0 +1,1243 @@
+/*
+ *	Interface to MP3 LAME encoding engine
+ *
+ *	Copyright (c) 1999 Mark Taylor
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/* $Id: lame.h,v 1.170.2.4 2009/01/18 15:44:28 robert Exp $ */
+
+#ifndef LAME_LAME_H
+#define LAME_LAME_H
+
+/* for size_t typedef */
+#include <stddef.h>
+/* for va_list typedef */
+#include <stdarg.h>
+/* for FILE typedef, TODO: remove when removing lame_mp3_tags_fid */
+#include <stdio.h>
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+#if defined(WIN32) || defined(_WIN32)
+#undef CDECL
+#define CDECL __cdecl
+#else
+#define CDECL
+#endif
+
+
+#define DEPRECATED_OR_OBSOLETE_CODE_REMOVED 1
+
+
+typedef enum vbr_mode_e {
+  vbr_off=0,
+  vbr_mt,               /* obsolete, same as vbr_mtrh */
+  vbr_rh,
+  vbr_abr,
+  vbr_mtrh,
+  vbr_max_indicator,    /* Don't use this! It's used for sanity checks.       */
+  vbr_default=vbr_mtrh    /* change this to change the default VBR mode of LAME */
+} vbr_mode;
+
+
+/* MPEG modes */
+typedef enum MPEG_mode_e {
+  STEREO = 0,
+  JOINT_STEREO,
+  DUAL_CHANNEL,   /* LAME doesn't supports this! */
+  MONO,
+  NOT_SET,
+  MAX_INDICATOR   /* Don't use this! It's used for sanity checks. */
+} MPEG_mode;
+
+/* Padding types */
+typedef enum Padding_type_e {
+  PAD_NO = 0,
+  PAD_ALL,
+  PAD_ADJUST,
+  PAD_MAX_INDICATOR   /* Don't use this! It's used for sanity checks. */
+} Padding_type;
+
+
+
+/*presets*/
+typedef enum preset_mode_e {
+    /*values from 8 to 320 should be reserved for abr bitrates*/
+    /*for abr I'd suggest to directly use the targeted bitrate as a value*/
+    ABR_8 = 8,
+    ABR_320 = 320,
+
+    V9 = 410, /*Vx to match Lame and VBR_xx to match FhG*/
+    VBR_10 = 410,
+    V8 = 420,
+    VBR_20 = 420,
+    V7 = 430,
+    VBR_30 = 430,
+    V6 = 440,
+    VBR_40 = 440,
+    V5 = 450,
+    VBR_50 = 450,
+    V4 = 460,
+    VBR_60 = 460,
+    V3 = 470,
+    VBR_70 = 470,
+    V2 = 480,
+    VBR_80 = 480,
+    V1 = 490,
+    VBR_90 = 490,
+    V0 = 500,
+    VBR_100 = 500,
+
+
+
+    /*still there for compatibility*/
+    R3MIX = 1000,
+    STANDARD = 1001,
+    EXTREME = 1002,
+    INSANE = 1003,
+    STANDARD_FAST = 1004,
+    EXTREME_FAST = 1005,
+    MEDIUM = 1006,
+    MEDIUM_FAST = 1007
+} preset_mode;
+
+
+/*asm optimizations*/
+typedef enum asm_optimizations_e {
+    MMX = 1,
+    AMD_3DNOW = 2,
+    SSE = 3
+} asm_optimizations;
+
+
+/* psychoacoustic model */
+typedef enum Psy_model_e {
+    PSY_GPSYCHO = 1,
+    PSY_NSPSYTUNE = 2
+} Psy_model;
+
+
+struct lame_global_struct;
+typedef struct lame_global_struct lame_global_flags;
+typedef lame_global_flags *lame_t;
+
+
+
+
+/***********************************************************************
+ *
+ *  The LAME API
+ *  These functions should be called, in this order, for each
+ *  MP3 file to be encoded.  See the file "API" for more documentation
+ *
+ ***********************************************************************/
+
+
+/*
+ * REQUIRED:
+ * initialize the encoder.  sets default for all encoder parameters,
+ * returns NULL if some malloc()'s failed
+ * otherwise returns pointer to structure needed for all future
+ * API calls.
+ */
+lame_global_flags * CDECL lame_init(void);
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/* obsolete version */
+int CDECL lame_init_old(lame_global_flags *);
+#endif
+
+/*
+ * OPTIONAL:
+ * set as needed to override defaults
+ */
+
+/********************************************************************
+ *  input stream description
+ ***********************************************************************/
+/* number of samples.  default = 2^32-1   */
+int CDECL lame_set_num_samples(lame_global_flags *, unsigned long);
+unsigned long CDECL lame_get_num_samples(const lame_global_flags *);
+
+/* input sample rate in Hz.  default = 44100hz */
+int CDECL lame_set_in_samplerate(lame_global_flags *, int);
+int CDECL lame_get_in_samplerate(const lame_global_flags *);
+
+/* number of channels in input stream. default=2  */
+int CDECL lame_set_num_channels(lame_global_flags *, int);
+int CDECL lame_get_num_channels(const lame_global_flags *);
+
+/*
+  scale the input by this amount before encoding.  default=0 (disabled)
+  (not used by decoding routines)
+*/
+int CDECL lame_set_scale(lame_global_flags *, float);
+float CDECL lame_get_scale(const lame_global_flags *);
+
+/*
+  scale the channel 0 (left) input by this amount before encoding.
+    default=0 (disabled)
+  (not used by decoding routines)
+*/
+int CDECL lame_set_scale_left(lame_global_flags *, float);
+float CDECL lame_get_scale_left(const lame_global_flags *);
+
+/*
+  scale the channel 1 (right) input by this amount before encoding.
+    default=0 (disabled)
+  (not used by decoding routines)
+*/
+int CDECL lame_set_scale_right(lame_global_flags *, float);
+float CDECL lame_get_scale_right(const lame_global_flags *);
+
+/*
+  output sample rate in Hz.  default = 0, which means LAME picks best value
+  based on the amount of compression.  MPEG only allows:
+  MPEG1    32, 44.1,   48khz
+  MPEG2    16, 22.05,  24
+  MPEG2.5   8, 11.025, 12
+  (not used by decoding routines)
+*/
+int CDECL lame_set_out_samplerate(lame_global_flags *, int);
+int CDECL lame_get_out_samplerate(const lame_global_flags *);
+
+
+/********************************************************************
+ *  general control parameters
+ ***********************************************************************/
+/* 1=cause LAME to collect data for an MP3 frame analyzer. default=0 */
+int CDECL lame_set_analysis(lame_global_flags *, int);
+int CDECL lame_get_analysis(const lame_global_flags *);
+
+/*
+  1 = write a Xing VBR header frame.
+  default = 1
+  this variable must have been added by a Hungarian notation Windows programmer :-)
+*/
+int CDECL lame_set_bWriteVbrTag(lame_global_flags *, int);
+int CDECL lame_get_bWriteVbrTag(const lame_global_flags *);
+
+/* 1=decode only.  use lame/mpglib to convert mp3/ogg to wav.  default=0 */
+int CDECL lame_set_decode_only(lame_global_flags *, int);
+int CDECL lame_get_decode_only(const lame_global_flags *);
+
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/* 1=encode a Vorbis .ogg file.  default=0 */
+/* DEPRECATED */
+int CDECL lame_set_ogg(lame_global_flags *, int);
+int CDECL lame_get_ogg(const lame_global_flags *);
+#endif
+
+/*
+  internal algorithm selection.  True quality is determined by the bitrate
+  but this variable will effect quality by selecting expensive or cheap algorithms.
+  quality=0..9.  0=best (very slow).  9=worst.
+  recommended:  2     near-best quality, not too slow
+                5     good quality, fast
+                7     ok quality, really fast
+*/
+int CDECL lame_set_quality(lame_global_flags *, int);
+int CDECL lame_get_quality(const lame_global_flags *);
+
+/*
+  mode = 0,1,2,3 = stereo, jstereo, dual channel (not supported), mono
+  default: lame picks based on compression ration and input channels
+*/
+int CDECL lame_set_mode(lame_global_flags *, MPEG_mode);
+MPEG_mode CDECL lame_get_mode(const lame_global_flags *);
+
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/*
+  mode_automs.  Use a M/S mode with a switching threshold based on
+  compression ratio
+  DEPRECATED
+*/
+int CDECL lame_set_mode_automs(lame_global_flags *, int);
+int CDECL lame_get_mode_automs(const lame_global_flags *);
+#endif
+
+/*
+  force_ms.  Force M/S for all frames.  For testing only.
+  default = 0 (disabled)
+*/
+int CDECL lame_set_force_ms(lame_global_flags *, int);
+int CDECL lame_get_force_ms(const lame_global_flags *);
+
+/* use free_format?  default = 0 (disabled) */
+int CDECL lame_set_free_format(lame_global_flags *, int);
+int CDECL lame_get_free_format(const lame_global_flags *);
+
+/* perform ReplayGain analysis?  default = 0 (disabled) */
+int CDECL lame_set_findReplayGain(lame_global_flags *, int);
+int CDECL lame_get_findReplayGain(const lame_global_flags *);
+
+/* decode on the fly. Search for the peak sample. If the ReplayGain
+ * analysis is enabled then perform the analysis on the decoded data
+ * stream. default = 0 (disabled)
+ * NOTE: if this option is set the build-in decoder should not be used */
+int CDECL lame_set_decode_on_the_fly(lame_global_flags *, int);
+int CDECL lame_get_decode_on_the_fly(const lame_global_flags *);
+
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/* DEPRECATED: now does the same as lame_set_findReplayGain()
+   default = 0 (disabled) */
+int CDECL lame_set_ReplayGain_input(lame_global_flags *, int);
+int CDECL lame_get_ReplayGain_input(const lame_global_flags *);
+
+/* DEPRECATED: now does the same as
+   lame_set_decode_on_the_fly() && lame_set_findReplayGain()
+   default = 0 (disabled) */
+int CDECL lame_set_ReplayGain_decode(lame_global_flags *, int);
+int CDECL lame_get_ReplayGain_decode(const lame_global_flags *);
+
+/* DEPRECATED: now does the same as lame_set_decode_on_the_fly()
+   default = 0 (disabled) */
+int CDECL lame_set_findPeakSample(lame_global_flags *, int);
+int CDECL lame_get_findPeakSample(const lame_global_flags *);
+#endif
+
+/* counters for gapless encoding */
+int CDECL lame_set_nogap_total(lame_global_flags*, int);
+int CDECL lame_get_nogap_total(const lame_global_flags*);
+
+int CDECL lame_set_nogap_currentindex(lame_global_flags* , int);
+int CDECL lame_get_nogap_currentindex(const lame_global_flags*);
+
+
+/*
+ * OPTIONAL:
+ * Set printf like error/debug/message reporting functions.
+ * The second argument has to be a pointer to a function which looks like
+ *   void my_debugf(const char *format, va_list ap)
+ *   {
+ *       (void) vfprintf(stdout, format, ap);
+ *   }
+ * If you use NULL as the value of the pointer in the set function, the
+ * lame buildin function will be used (prints to stderr).
+ * To quiet any output you have to replace the body of the example function
+ * with just "return;" and use it in the set function.
+ */
+int CDECL lame_set_errorf(lame_global_flags *,
+                          void (*func)(const char *, va_list));
+int CDECL lame_set_debugf(lame_global_flags *,
+                          void (*func)(const char *, va_list));
+int CDECL lame_set_msgf  (lame_global_flags *,
+                          void (*func)(const char *, va_list));
+
+
+
+/* set one of brate compression ratio.  default is compression ratio of 11.  */
+int CDECL lame_set_brate(lame_global_flags *, int);
+int CDECL lame_get_brate(const lame_global_flags *);
+int CDECL lame_set_compression_ratio(lame_global_flags *, float);
+float CDECL lame_get_compression_ratio(const lame_global_flags *);
+
+
+int CDECL lame_set_preset( lame_global_flags*  gfp, int );
+int CDECL lame_set_asm_optimizations( lame_global_flags*  gfp, int, int );
+
+
+
+/********************************************************************
+ *  frame params
+ ***********************************************************************/
+/* mark as copyright.  default=0 */
+int CDECL lame_set_copyright(lame_global_flags *, int);
+int CDECL lame_get_copyright(const lame_global_flags *);
+
+/* mark as original.  default=1 */
+int CDECL lame_set_original(lame_global_flags *, int);
+int CDECL lame_get_original(const lame_global_flags *);
+
+/* error_protection.  Use 2 bytes from each frame for CRC checksum. default=0 */
+int CDECL lame_set_error_protection(lame_global_flags *, int);
+int CDECL lame_get_error_protection(const lame_global_flags *);
+
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/* padding_type. 0=pad no frames  1=pad all frames 2=adjust padding(default) */
+int CDECL lame_set_padding_type(lame_global_flags *, Padding_type);
+Padding_type CDECL lame_get_padding_type(const lame_global_flags *);
+#endif
+
+/* MP3 'private extension' bit  Meaningless.  default=0 */
+int CDECL lame_set_extension(lame_global_flags *, int);
+int CDECL lame_get_extension(const lame_global_flags *);
+
+/* enforce strict ISO compliance.  default=0 */
+int CDECL lame_set_strict_ISO(lame_global_flags *, int);
+int CDECL lame_get_strict_ISO(const lame_global_flags *);
+
+
+/********************************************************************
+ * quantization/noise shaping
+ ***********************************************************************/
+
+/* disable the bit reservoir. For testing only. default=0 */
+int CDECL lame_set_disable_reservoir(lame_global_flags *, int);
+int CDECL lame_get_disable_reservoir(const lame_global_flags *);
+
+/* select a different "best quantization" function. default=0  */
+int CDECL lame_set_quant_comp(lame_global_flags *, int);
+int CDECL lame_get_quant_comp(const lame_global_flags *);
+int CDECL lame_set_quant_comp_short(lame_global_flags *, int);
+int CDECL lame_get_quant_comp_short(const lame_global_flags *);
+
+int CDECL lame_set_experimentalX(lame_global_flags *, int); /* compatibility*/
+int CDECL lame_get_experimentalX(const lame_global_flags *);
+
+/* another experimental option.  for testing only */
+int CDECL lame_set_experimentalY(lame_global_flags *, int);
+int CDECL lame_get_experimentalY(const lame_global_flags *);
+
+/* another experimental option.  for testing only */
+int CDECL lame_set_experimentalZ(lame_global_flags *, int);
+int CDECL lame_get_experimentalZ(const lame_global_flags *);
+
+/* Naoki's psycho acoustic model.  default=0 */
+int CDECL lame_set_exp_nspsytune(lame_global_flags *, int);
+int CDECL lame_get_exp_nspsytune(const lame_global_flags *);
+
+void CDECL lame_set_msfix(lame_global_flags *, double);
+float CDECL lame_get_msfix(const lame_global_flags *);
+
+
+/********************************************************************
+ * VBR control
+ ***********************************************************************/
+/* Types of VBR.  default = vbr_off = CBR */
+int CDECL lame_set_VBR(lame_global_flags *, vbr_mode);
+vbr_mode CDECL lame_get_VBR(const lame_global_flags *);
+
+/* VBR quality level.  0=highest  9=lowest  */
+int CDECL lame_set_VBR_q(lame_global_flags *, int);
+int CDECL lame_get_VBR_q(const lame_global_flags *);
+
+/* VBR quality level.  0=highest  9=lowest, Range [0,...,10[  */
+int CDECL lame_set_VBR_quality(lame_global_flags *, float);
+float CDECL lame_get_VBR_quality(const lame_global_flags *);
+
+/* Ignored except for VBR=vbr_abr (ABR mode) */
+int CDECL lame_set_VBR_mean_bitrate_kbps(lame_global_flags *, int);
+int CDECL lame_get_VBR_mean_bitrate_kbps(const lame_global_flags *);
+
+int CDECL lame_set_VBR_min_bitrate_kbps(lame_global_flags *, int);
+int CDECL lame_get_VBR_min_bitrate_kbps(const lame_global_flags *);
+
+int CDECL lame_set_VBR_max_bitrate_kbps(lame_global_flags *, int);
+int CDECL lame_get_VBR_max_bitrate_kbps(const lame_global_flags *);
+
+/*
+  1=strictly enforce VBR_min_bitrate.  Normally it will be violated for
+  analog silence
+*/
+int CDECL lame_set_VBR_hard_min(lame_global_flags *, int);
+int CDECL lame_get_VBR_hard_min(const lame_global_flags *);
+
+/* for preset */
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+int CDECL lame_set_preset_expopts(lame_global_flags *, int);
+#endif
+
+/********************************************************************
+ * Filtering control
+ ***********************************************************************/
+/* freq in Hz to apply lowpass. Default = 0 = lame chooses.  -1 = disabled */
+int CDECL lame_set_lowpassfreq(lame_global_flags *, int);
+int CDECL lame_get_lowpassfreq(const lame_global_flags *);
+/* width of transition band, in Hz.  Default = one polyphase filter band */
+int CDECL lame_set_lowpasswidth(lame_global_flags *, int);
+int CDECL lame_get_lowpasswidth(const lame_global_flags *);
+
+/* freq in Hz to apply highpass. Default = 0 = lame chooses.  -1 = disabled */
+int CDECL lame_set_highpassfreq(lame_global_flags *, int);
+int CDECL lame_get_highpassfreq(const lame_global_flags *);
+/* width of transition band, in Hz.  Default = one polyphase filter band */
+int CDECL lame_set_highpasswidth(lame_global_flags *, int);
+int CDECL lame_get_highpasswidth(const lame_global_flags *);
+
+
+/********************************************************************
+ * psycho acoustics and other arguments which you should not change
+ * unless you know what you are doing
+ ***********************************************************************/
+
+/* only use ATH for masking */
+int CDECL lame_set_ATHonly(lame_global_flags *, int);
+int CDECL lame_get_ATHonly(const lame_global_flags *);
+
+/* only use ATH for short blocks */
+int CDECL lame_set_ATHshort(lame_global_flags *, int);
+int CDECL lame_get_ATHshort(const lame_global_flags *);
+
+/* disable ATH */
+int CDECL lame_set_noATH(lame_global_flags *, int);
+int CDECL lame_get_noATH(const lame_global_flags *);
+
+/* select ATH formula */
+int CDECL lame_set_ATHtype(lame_global_flags *, int);
+int CDECL lame_get_ATHtype(const lame_global_flags *);
+
+/* lower ATH by this many db */
+int CDECL lame_set_ATHlower(lame_global_flags *, float);
+float CDECL lame_get_ATHlower(const lame_global_flags *);
+
+/* select ATH adaptive adjustment type */
+int CDECL lame_set_athaa_type( lame_global_flags *, int);
+int CDECL lame_get_athaa_type( const lame_global_flags *);
+
+/* select the loudness approximation used by the ATH adaptive auto-leveling  */
+int CDECL lame_set_athaa_loudapprox( lame_global_flags *, int);
+int CDECL lame_get_athaa_loudapprox( const lame_global_flags *);
+
+/* adjust (in dB) the point below which adaptive ATH level adjustment occurs */
+int CDECL lame_set_athaa_sensitivity( lame_global_flags *, float);
+float CDECL lame_get_athaa_sensitivity( const lame_global_flags* );
+
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/* OBSOLETE: predictability limit (ISO tonality formula) */
+int CDECL lame_set_cwlimit(lame_global_flags *, int);
+int CDECL lame_get_cwlimit(const lame_global_flags *);
+#endif
+
+/*
+  allow blocktypes to differ between channels?
+  default: 0 for jstereo, 1 for stereo
+*/
+int CDECL lame_set_allow_diff_short(lame_global_flags *, int);
+int CDECL lame_get_allow_diff_short(const lame_global_flags *);
+
+/* use temporal masking effect (default = 1) */
+int CDECL lame_set_useTemporal(lame_global_flags *, int);
+int CDECL lame_get_useTemporal(const lame_global_flags *);
+
+/* use temporal masking effect (default = 1) */
+int CDECL lame_set_interChRatio(lame_global_flags *, float);
+float CDECL lame_get_interChRatio(const lame_global_flags *);
+
+/* disable short blocks */
+int CDECL lame_set_no_short_blocks(lame_global_flags *, int);
+int CDECL lame_get_no_short_blocks(const lame_global_flags *);
+
+/* force short blocks */
+int CDECL lame_set_force_short_blocks(lame_global_flags *, int);
+int CDECL lame_get_force_short_blocks(const lame_global_flags *);
+
+/* Input PCM is emphased PCM (for instance from one of the rarely
+   emphased CDs), it is STRONGLY not recommended to use this, because
+   psycho does not take it into account, and last but not least many decoders
+   ignore these bits */
+int CDECL lame_set_emphasis(lame_global_flags *, int);
+int CDECL lame_get_emphasis(const lame_global_flags *);
+
+
+
+/************************************************************************/
+/* internal variables, cannot be set...                                 */
+/* provided because they may be of use to calling application           */
+/************************************************************************/
+/* version  0=MPEG-2  1=MPEG-1  (2=MPEG-2.5)     */
+int CDECL lame_get_version(const lame_global_flags *);
+
+/* encoder delay   */
+int CDECL lame_get_encoder_delay(const lame_global_flags *);
+
+/*
+  padding appended to the input to make sure decoder can fully decode
+  all input.  Note that this value can only be calculated during the
+  call to lame_encoder_flush().  Before lame_encoder_flush() has
+  been called, the value of encoder_padding = 0.
+*/
+int CDECL lame_get_encoder_padding(const lame_global_flags *);
+
+/* size of MPEG frame */
+int CDECL lame_get_framesize(const lame_global_flags *);
+
+/* number of PCM samples buffered, but not yet encoded to mp3 data. */
+int CDECL lame_get_mf_samples_to_encode( const lame_global_flags*  gfp );
+
+/*
+  size (bytes) of mp3 data buffered, but not yet encoded.
+  this is the number of bytes which would be output by a call to
+  lame_encode_flush_nogap.  NOTE: lame_encode_flush() will return
+  more bytes than this because it will encode the reamining buffered
+  PCM samples before flushing the mp3 buffers.
+*/
+int CDECL lame_get_size_mp3buffer( const lame_global_flags*  gfp );
+
+/* number of frames encoded so far */
+int CDECL lame_get_frameNum(const lame_global_flags *);
+
+/*
+  lame's estimate of the total number of frames to be encoded
+   only valid if calling program set num_samples
+*/
+int CDECL lame_get_totalframes(const lame_global_flags *);
+
+/* RadioGain value. Multiplied by 10 and rounded to the nearest. */
+int CDECL lame_get_RadioGain(const lame_global_flags *);
+
+/* AudiophileGain value. Multipled by 10 and rounded to the nearest. */
+int CDECL lame_get_AudiophileGain(const lame_global_flags *);
+
+/* the peak sample */
+float CDECL lame_get_PeakSample(const lame_global_flags *);
+
+/* Gain change required for preventing clipping. The value is correct only if
+   peak sample searching was enabled. If negative then the waveform
+   already does not clip. The value is multiplied by 10 and rounded up. */
+int CDECL lame_get_noclipGainChange(const lame_global_flags *);
+
+/* user-specified scale factor required for preventing clipping. Value is
+   correct only if peak sample searching was enabled and no user-specified
+   scaling was performed. If negative then either the waveform already does
+   not clip or the value cannot be determined */
+float CDECL lame_get_noclipScale(const lame_global_flags *);
+
+
+
+
+
+
+
+/*
+ * REQUIRED:
+ * sets more internal configuration based on data provided above.
+ * returns -1 if something failed.
+ */
+int CDECL lame_init_params(lame_global_flags *);
+
+
+/*
+ * OPTIONAL:
+ * get the version number, in a string. of the form:
+ * "3.63 (beta)" or just "3.63".
+ */
+const char*  CDECL get_lame_version       ( void );
+const char*  CDECL get_lame_short_version ( void );
+const char*  CDECL get_lame_very_short_version ( void );
+const char*  CDECL get_psy_version        ( void );
+const char*  CDECL get_lame_url           ( void );
+const char*  CDECL get_lame_os_bitness    ( void );
+
+/*
+ * OPTIONAL:
+ * get the version numbers in numerical form.
+ */
+typedef struct {
+    /* generic LAME version */
+    int major;
+    int minor;
+    int alpha;               /* 0 if not an alpha version                  */
+    int beta;                /* 0 if not a beta version                    */
+
+    /* version of the psy model */
+    int psy_major;
+    int psy_minor;
+    int psy_alpha;           /* 0 if not an alpha version                  */
+    int psy_beta;            /* 0 if not a beta version                    */
+
+    /* compile time features */
+    const char *features;    /* Don't make assumptions about the contents! */
+} lame_version_t;
+void CDECL get_lame_version_numerical(lame_version_t *);
+
+
+/*
+ * OPTIONAL:
+ * print internal lame configuration to message handler
+ */
+void CDECL lame_print_config(const lame_global_flags*  gfp);
+
+void CDECL lame_print_internals( const lame_global_flags *gfp);
+
+
+/*
+ * input pcm data, output (maybe) mp3 frames.
+ * This routine handles all buffering, resampling and filtering for you.
+ *
+ * return code     number of bytes output in mp3buf. Can be 0
+ *                 -1:  mp3buf was too small
+ *                 -2:  malloc() problem
+ *                 -3:  lame_init_params() not called
+ *                 -4:  psycho acoustic problems
+ *
+ * The required mp3buf_size can be computed from num_samples,
+ * samplerate and encoding rate, but here is a worst case estimate:
+ *
+ * mp3buf_size in bytes = 1.25*num_samples + 7200
+ *
+ * I think a tighter bound could be:  (mt, March 2000)
+ * MPEG1:
+ *    num_samples*(bitrate/8)/samplerate + 4*1152*(bitrate/8)/samplerate + 512
+ * MPEG2:
+ *    num_samples*(bitrate/8)/samplerate + 4*576*(bitrate/8)/samplerate + 256
+ *
+ * but test first if you use that!
+ *
+ * set mp3buf_size = 0 and LAME will not check if mp3buf_size is
+ * large enough.
+ *
+ * NOTE:
+ * if gfp->num_channels=2, but gfp->mode = 3 (mono), the L & R channels
+ * will be averaged into the L channel before encoding only the L channel
+ * This will overwrite the data in buffer_l[] and buffer_r[].
+ *
+*/
+int CDECL lame_encode_buffer (
+        lame_global_flags*  gfp,           /* global context handle         */
+        const short int     buffer_l [],   /* PCM data for left channel     */
+        const short int     buffer_r [],   /* PCM data for right channel    */
+        const int           nsamples,      /* number of samples per channel */
+        unsigned char*      mp3buf,        /* pointer to encoded MP3 stream */
+        const int           mp3buf_size ); /* number of valid octets in this
+                                              stream                        */
+
+/*
+ * as above, but input has L & R channel data interleaved.
+ * NOTE:
+ * num_samples = number of samples in the L (or R)
+ * channel, not the total number of samples in pcm[]
+ */
+int CDECL lame_encode_buffer_interleaved(
+        lame_global_flags*  gfp,           /* global context handlei        */
+        short int           pcm[],         /* PCM data for left and right
+                                              channel, interleaved          */
+        int                 num_samples,   /* number of samples per channel,
+                                              _not_ number of samples in
+                                              pcm[]                         */
+        unsigned char*      mp3buf,        /* pointer to encoded MP3 stream */
+        int                 mp3buf_size ); /* number of valid octets in this
+                                              stream                        */
+
+
+/* as lame_encode_buffer, but for 'float's.
+ * !! NOTE: !! data must still be scaled to be in the same range as
+ * short int, +/- 32768
+ */
+int CDECL lame_encode_buffer_float(
+        lame_global_flags*  gfp,           /* global context handle         */
+        const float     buffer_l [],       /* PCM data for left channel     */
+        const float     buffer_r [],       /* PCM data for right channel    */
+        const int           nsamples,      /* number of samples per channel */
+        unsigned char*      mp3buf,        /* pointer to encoded MP3 stream */
+        const int           mp3buf_size ); /* number of valid octets in this
+                                              stream                        */
+
+
+/* as lame_encode_buffer, but for long's
+ * !! NOTE: !! data must still be scaled to be in the same range as
+ * short int, +/- 32768
+ *
+ * This scaling was a mistake (doesn't allow one to exploit full
+ * precision of type 'long'.  Use lame_encode_buffer_long2() instead.
+ *
+ */
+int CDECL lame_encode_buffer_long(
+        lame_global_flags*  gfp,           /* global context handle         */
+        const long     buffer_l [],       /* PCM data for left channel     */
+        const long     buffer_r [],       /* PCM data for right channel    */
+        const int           nsamples,      /* number of samples per channel */
+        unsigned char*      mp3buf,        /* pointer to encoded MP3 stream */
+        const int           mp3buf_size ); /* number of valid octets in this
+                                              stream                        */
+
+/* Same as lame_encode_buffer_long(), but with correct scaling.
+ * !! NOTE: !! data must still be scaled to be in the same range as
+ * type 'long'.   Data should be in the range:  +/- 2^(8*size(long)-1)
+ *
+ */
+int CDECL lame_encode_buffer_long2(
+        lame_global_flags*  gfp,           /* global context handle         */
+        const long     buffer_l [],       /* PCM data for left channel     */
+        const long     buffer_r [],       /* PCM data for right channel    */
+        const int           nsamples,      /* number of samples per channel */
+        unsigned char*      mp3buf,        /* pointer to encoded MP3 stream */
+        const int           mp3buf_size ); /* number of valid octets in this
+                                              stream                        */
+
+/* as lame_encode_buffer, but for int's
+ * !! NOTE: !! input should be scaled to the maximum range of 'int'
+ * If int is 4 bytes, then the values should range from
+ * +/- 2147483648.
+ *
+ * This routine does not (and cannot, without loosing precision) use
+ * the same scaling as the rest of the lame_encode_buffer() routines.
+ *
+ */
+int CDECL lame_encode_buffer_int(
+        lame_global_flags*  gfp,           /* global context handle         */
+        const int      buffer_l [],       /* PCM data for left channel     */
+        const int      buffer_r [],       /* PCM data for right channel    */
+        const int           nsamples,      /* number of samples per channel */
+        unsigned char*      mp3buf,        /* pointer to encoded MP3 stream */
+        const int           mp3buf_size ); /* number of valid octets in this
+                                              stream                        */
+
+
+
+
+
+/*
+ * REQUIRED:
+ * lame_encode_flush will flush the intenal PCM buffers, padding with
+ * 0's to make sure the final frame is complete, and then flush
+ * the internal MP3 buffers, and thus may return a
+ * final few mp3 frames.  'mp3buf' should be at least 7200 bytes long
+ * to hold all possible emitted data.
+ *
+ * will also write id3v1 tags (if any) into the bitstream
+ *
+ * return code = number of bytes output to mp3buf. Can be 0
+ */
+int CDECL lame_encode_flush(
+        lame_global_flags *  gfp,    /* global context handle                 */
+        unsigned char*       mp3buf, /* pointer to encoded MP3 stream         */
+        int                  size);  /* number of valid octets in this stream */
+
+/*
+ * OPTIONAL:
+ * lame_encode_flush_nogap will flush the internal mp3 buffers and pad
+ * the last frame with ancillary data so it is a complete mp3 frame.
+ *
+ * 'mp3buf' should be at least 7200 bytes long
+ * to hold all possible emitted data.
+ *
+ * After a call to this routine, the outputed mp3 data is complete, but
+ * you may continue to encode new PCM samples and write future mp3 data
+ * to a different file.  The two mp3 files will play back with no gaps
+ * if they are concatenated together.
+ *
+ * This routine will NOT write id3v1 tags into the bitstream.
+ *
+ * return code = number of bytes output to mp3buf. Can be 0
+ */
+int CDECL lame_encode_flush_nogap(
+        lame_global_flags *  gfp,    /* global context handle                 */
+        unsigned char*       mp3buf, /* pointer to encoded MP3 stream         */
+        int                  size);  /* number of valid octets in this stream */
+
+/*
+ * OPTIONAL:
+ * Normally, this is called by lame_init_params().  It writes id3v2 and
+ * Xing headers into the front of the bitstream, and sets frame counters
+ * and bitrate histogram data to 0.  You can also call this after
+ * lame_encode_flush_nogap().
+ */
+int CDECL lame_init_bitstream(
+        lame_global_flags *  gfp);    /* global context handle                 */
+
+
+
+/*
+ * OPTIONAL:    some simple statistics
+ * a bitrate histogram to visualize the distribution of used frame sizes
+ * a stereo mode histogram to visualize the distribution of used stereo
+ *   modes, useful in joint-stereo mode only
+ *   0: LR    left-right encoded
+ *   1: LR-I  left-right and intensity encoded (currently not supported)
+ *   2: MS    mid-side encoded
+ *   3: MS-I  mid-side and intensity encoded (currently not supported)
+ *
+ * attention: don't call them after lame_encode_finish
+ * suggested: lame_encode_flush -> lame_*_hist -> lame_close
+ */
+
+void CDECL lame_bitrate_hist(
+        const lame_global_flags * gfp,
+        int bitrate_count[14] );
+void CDECL lame_bitrate_kbps(
+        const lame_global_flags * gfp,
+        int bitrate_kbps [14] );
+void CDECL lame_stereo_mode_hist(
+        const lame_global_flags * gfp,
+        int stereo_mode_count[4] );
+
+void CDECL lame_bitrate_stereo_mode_hist (
+        const lame_global_flags * gfp,
+        int bitrate_stmode_count[14][4] );
+
+void CDECL lame_block_type_hist (
+        const lame_global_flags * gfp,
+        int btype_count[6] );
+
+void CDECL lame_bitrate_block_type_hist (
+        const lame_global_flags * gfp,
+        int bitrate_btype_count[14][6] );
+
+#if (DEPRECATED_OR_OBSOLETE_CODE_REMOVED && 0)
+#else
+/*
+ * OPTIONAL:
+ * lame_mp3_tags_fid will rewrite a Xing VBR tag to the mp3 file with file
+ * pointer fid.  These calls perform forward and backwards seeks, so make
+ * sure fid is a real file.  Make sure lame_encode_flush has been called,
+ * and all mp3 data has been written to the file before calling this
+ * function.
+ * NOTE:
+ * if VBR  tags are turned off by the user, or turned off by LAME because
+ * the output is not a regular file, this call does nothing
+ * NOTE:
+ * LAME wants to read from the file to skip an optional ID3v2 tag, so
+ * make sure you opened the file for writing and reading.
+ * NOTE:
+ * You can call lame_get_lametag_frame instead, if you want to insert
+ * the lametag yourself.
+*/
+void CDECL lame_mp3_tags_fid(lame_global_flags *, FILE* fid);
+#endif
+
+/*
+ * OPTIONAL:
+ * lame_get_lametag_frame copies the final LAME-tag into 'buffer'.
+ * The function returns the number of bytes copied into buffer, or
+ * the required buffer size, if the provided buffer is too small.
+ * Function failed, if the return value is larger than 'size'!
+ * Make sure lame_encode flush has been called before calling this function.
+ * NOTE:
+ * if VBR  tags are turned off by the user, or turned off by LAME,
+ * this call does nothing and returns 0.
+ * NOTE:
+ * LAME inserted an empty frame in the beginning of mp3 audio data,
+ * which you have to replace by the final LAME-tag frame after encoding.
+ * In case there is no ID3v2 tag, usually this frame will be the very first
+ * data in your mp3 file. If you put some other leading data into your
+ * file, you'll have to do some bookkeeping about where to write this buffer.
+ */
+size_t CDECL lame_get_lametag_frame(
+        const lame_global_flags *, unsigned char* buffer, size_t size);
+
+/*
+ * REQUIRED:
+ * final call to free all remaining buffers
+ */
+int  CDECL lame_close (lame_global_flags *);
+
+#if DEPRECATED_OR_OBSOLETE_CODE_REMOVED
+#else
+/*
+ * OBSOLETE:
+ * lame_encode_finish combines lame_encode_flush() and lame_close() in
+ * one call.  However, once this call is made, the statistics routines
+ * will no longer work because the data will have been cleared, and
+ * lame_mp3_tags_fid() cannot be called to add data to the VBR header
+ */
+int CDECL lame_encode_finish(
+        lame_global_flags*  gfp,
+        unsigned char*      mp3buf,
+        int                 size );
+#endif
+
+
+
+
+
+
+/*********************************************************************
+ *
+ * decoding
+ *
+ * a simple interface to mpglib, part of mpg123, is also included if
+ * libmp3lame is compiled with HAVE_MPGLIB
+ *
+ *********************************************************************/
+
+struct hip_global_struct;
+typedef struct hip_global_struct hip_global_flags;
+typedef hip_global_flags *hip_t;
+
+
+typedef struct {
+  int header_parsed;   /* 1 if header was parsed and following data was
+                          computed                                       */
+  int stereo;          /* number of channels                             */
+  int samplerate;      /* sample rate                                    */
+  int bitrate;         /* bitrate                                        */
+  int mode;            /* mp3 frame type                                 */
+  int mode_ext;        /* mp3 frame type                                 */
+  int framesize;       /* number of samples per mp3 frame                */
+
+  /* this data is only computed if mpglib detects a Xing VBR header */
+  unsigned long nsamp; /* number of samples in mp3 file.                 */
+  int totalframes;     /* total number of frames in mp3 file             */
+
+  /* this data is not currently computed by the mpglib routines */
+  int framenum;        /* frames decoded counter                         */
+} mp3data_struct;
+
+/* required call to initialize decoder */
+hip_t CDECL hip_decode_init(void);
+
+/* cleanup call to exit decoder  */
+int CDECL hip_decode_exit(hip_t gfp);
+
+/*********************************************************************
+ * input 1 mp3 frame, output (maybe) pcm data.
+ *
+ *  nout = hip_decode(hip, mp3buf,len,pcm_l,pcm_r);
+ *
+ * input:
+ *    len          :  number of bytes of mp3 data in mp3buf
+ *    mp3buf[len]  :  mp3 data to be decoded
+ *
+ * output:
+ *    nout:  -1    : decoding error
+ *            0    : need more data before we can complete the decode
+ *           >0    : returned 'nout' samples worth of data in pcm_l,pcm_r
+ *    pcm_l[nout]  : left channel data
+ *    pcm_r[nout]  : right channel data
+ *
+ *********************************************************************/
+int CDECL hip_decode( hip_t           gfp
+                    , unsigned char * mp3buf
+                    , size_t          len
+                    , short           pcm_l[]
+                    , short           pcm_r[]
+                    );
+
+/* same as hip_decode, and also returns mp3 header data */
+int CDECL hip_decode_headers( hip_t           gfp
+                            , unsigned char*  mp3buf
+                            , size_t          len
+                            , short           pcm_l[]
+                            , short           pcm_r[]
+                            , mp3data_struct* mp3data
+                            );
+
+/* same as hip_decode, but returns at most one frame */
+int CDECL hip_decode1( hip_t          gfp
+                     , unsigned char* mp3buf
+                     , size_t         len
+                     , short          pcm_l[]
+                     , short          pcm_r[]
+                     );
+
+/* same as hip_decode1, but returns at most one frame and mp3 header data */
+int CDECL hip_decode1_headers( hip_t           gfp
+                             , unsigned char*  mp3buf
+                             , size_t          len
+                             , short           pcm_l[]
+                             , short           pcm_r[]
+                             , mp3data_struct* mp3data
+                             );
+
+/* same as hip_decode1_headers, but also returns enc_delay and enc_padding
+   from VBR Info tag, (-1 if no info tag was found) */
+int CDECL hip_decode1_headersB( hip_t gfp
+                              , unsigned char*   mp3buf
+                              , size_t           len
+                              , short            pcm_l[]
+                              , short            pcm_r[]
+                              , mp3data_struct*  mp3data
+                              , int             *enc_delay
+                              , int             *enc_padding
+                              );
+
+
+
+/* OBSOLETE:
+ * lame_decode... functions are there to keep old code working
+ * but it is strongly recommended to replace calls by hip_decode...
+ * function calls, see above.
+ */
+#if 1
+int CDECL lame_decode_init(void);
+int CDECL lame_decode(
+        unsigned char *  mp3buf,
+        int              len,
+        short            pcm_l[],
+        short            pcm_r[] );
+int CDECL lame_decode_headers(
+        unsigned char*   mp3buf,
+        int              len,
+        short            pcm_l[],
+        short            pcm_r[],
+        mp3data_struct*  mp3data );
+int CDECL lame_decode1(
+        unsigned char*  mp3buf,
+        int             len,
+        short           pcm_l[],
+        short           pcm_r[] );
+int CDECL lame_decode1_headers(
+        unsigned char*   mp3buf,
+        int              len,
+        short            pcm_l[],
+        short            pcm_r[],
+        mp3data_struct*  mp3data );
+int CDECL lame_decode1_headersB(
+        unsigned char*   mp3buf,
+        int              len,
+        short            pcm_l[],
+        short            pcm_r[],
+        mp3data_struct*  mp3data,
+        int              *enc_delay,
+        int              *enc_padding );
+int CDECL lame_decode_exit(void);
+
+#endif /* obsolete lame_decode API calls */
+
+
+/*********************************************************************
+ *
+ * id3tag stuff
+ *
+ *********************************************************************/
+
+/*
+ * id3tag.h -- Interface to write ID3 version 1 and 2 tags.
+ *
+ * Copyright (C) 2000 Don Melton.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* utility to obtain alphabetically sorted list of genre names with numbers */
+void CDECL id3tag_genre_list(
+        void (*handler)(int, const char *, void *),
+        void*  cookie);
+
+void CDECL id3tag_init     (lame_t gfp);
+
+/* force addition of version 2 tag */
+void CDECL id3tag_add_v2   (lame_t gfp);
+
+/* add only a version 1 tag */
+void CDECL id3tag_v1_only  (lame_t gfp);
+
+/* add only a version 2 tag */
+void CDECL id3tag_v2_only  (lame_t gfp);
+
+/* pad version 1 tag with spaces instead of nulls */
+void CDECL id3tag_space_v1 (lame_t gfp);
+
+/* pad version 2 tag with extra 128 bytes */
+void CDECL id3tag_pad_v2   (lame_t gfp);
+
+/* pad version 2 tag with extra n bytes */
+void CDECL id3tag_set_pad  (lame_t gfp, size_t n);
+
+void CDECL id3tag_set_title(lame_t gfp, const char* title);
+void CDECL id3tag_set_artist(lame_t gfp, const char* artist);
+void CDECL id3tag_set_album(lame_t gfp, const char* album);
+void CDECL id3tag_set_year(lame_t gfp, const char* year);
+void CDECL id3tag_set_comment(lame_t gfp, const char* comment);
+            
+/* return -1 result if track number is out of ID3v1 range
+                    and ignored for ID3v1 */
+int CDECL id3tag_set_track(lame_t gfp, const char* track);
+
+/* return non-zero result if genre name or number is invalid
+  result 0: OK
+  result -1: genre number out of range
+  result -2: no valid ID3v1 genre name, mapped to ID3v1 'Other'
+             but taken as-is for ID3v2 genre tag */
+int CDECL id3tag_set_genre(lame_t gfp, const char* genre);
+
+/* return non-zero result if field name is invalid */
+int CDECL id3tag_set_fieldvalue(lame_t gfp, const char* fieldvalue);
+
+/* return non-zero result if image type is invalid */
+int CDECL id3tag_set_albumart(lame_t gfp, const char* image, size_t size);
+
+/* lame_get_id3v1_tag copies ID3v1 tag into buffer.
+ * Function returns number of bytes copied into buffer, or number
+ * of bytes rquired if buffer 'size' is too small.
+ * Function fails, if returned value is larger than 'size'.
+ * NOTE:
+ * This functions does nothing, if user/LAME disabled ID3v1 tag.
+ */
+size_t CDECL lame_get_id3v1_tag(lame_t gfp, unsigned char* buffer, size_t size);
+
+/* lame_get_id3v2_tag copies ID3v2 tag into buffer.
+ * Function returns number of bytes copied into buffer, or number
+ * of bytes rquired if buffer 'size' is too small.
+ * Function fails, if returned value is larger than 'size'.
+ * NOTE:
+ * This functions does nothing, if user/LAME disabled ID3v2 tag.
+ */
+size_t CDECL lame_get_id3v2_tag(lame_t gfp, unsigned char* buffer, size_t size);
+
+/* normaly lame_init_param writes ID3v2 tags into the audio stream
+ * Call lame_set_write_id3tag_automatic(gfp, 0) before lame_init_param
+ * to turn off this behaviour and get ID3v2 tag with above function
+ * write it yourself into your file.
+ */
+void CDECL lame_set_write_id3tag_automatic(lame_global_flags * gfp, int);
+int CDECL lame_get_write_id3tag_automatic(lame_global_flags const* gfp);
+
+/***********************************************************************
+*
+*  list of valid bitrates [kbps] & sample frequencies [Hz].
+*  first index: 0: MPEG-2   values  (sample frequencies 16...24 kHz)
+*               1: MPEG-1   values  (sample frequencies 32...48 kHz)
+*               2: MPEG-2.5 values  (sample frequencies  8...12 kHz)
+***********************************************************************/
+extern const int      bitrate_table    [3] [16];
+extern const int      samplerate_table [3] [ 4];
+
+
+
+/* maximum size of albumart image (128KB), which affects LAME_MAXMP3BUFFER
+   as well since lame_encode_buffer() also returns ID3v2 tag data */
+#define LAME_MAXALBUMART    (128 * 1024)
+
+/* maximum size of mp3buffer needed if you encode at most 1152 samples for
+   each call to lame_encode_buffer.  see lame_encode_buffer() below  
+   (LAME_MAXMP3BUFFER is now obsolete)  */
+#define LAME_MAXMP3BUFFER   (16384 + LAME_MAXALBUMART)
+
+
+typedef enum {
+    LAME_OKAY             =   0,
+    LAME_NOERROR          =   0,
+    LAME_GENERICERROR     =  -1,
+    LAME_NOMEM            = -10,
+    LAME_BADBITRATE       = -11,
+    LAME_BADSAMPFREQ      = -12,
+    LAME_INTERNALERROR    = -13,
+
+    FRONTEND_READERROR    = -80,
+    FRONTEND_WRITEERROR   = -81,
+    FRONTEND_FILETOOLARGE = -82
+
+} lame_errorcodes_t;
+
+#if defined(__cplusplus)
+}
+#endif
+#endif /* LAME_LAME_H */
+
--- ffmpeg-1.0/localinc/neaacdec.h.dlopen~	2012-10-08 14:40:29.809299279 +0200
+++ ffmpeg-1.0/localinc/neaacdec.h	2012-10-08 14:40:29.809299279 +0200
@@ -0,0 +1,258 @@
+/*
+** FAAD2 - Freeware Advanced Audio (AAC) Decoder including SBR decoding
+** Copyright (C) 2003-2005 M. Bakker, Nero AG, http://www.nero.com
+**  
+** This program is free software; you can redistribute it and/or modify
+** it under the terms of the GNU General Public License as published by
+** the Free Software Foundation; either version 2 of the License, or
+** (at your option) any later version.
+** 
+** This program is distributed in the hope that it will be useful,
+** but WITHOUT ANY WARRANTY; without even the implied warranty of
+** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+** GNU General Public License for more details.
+** 
+** You should have received a copy of the GNU General Public License
+** along with this program; if not, write to the Free Software 
+** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+**
+** Any non-GPL usage of this software or parts of this software is strictly
+** forbidden.
+**
+** The "appropriate copyright message" mentioned in section 2c of the GPLv2
+** must read: "Code from FAAD2 is copyright (c) Nero AG, www.nero.com"
+**
+** Commercial non-GPL licensing of this software is possible.
+** For more info contact Nero AG through Mpeg4AAClicense@nero.com.
+**
+** $Id: neaacdec.h,v 1.13 2009/01/26 23:51:15 menno Exp $
+**/
+
+#ifndef __NEAACDEC_H__
+#define __NEAACDEC_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+#if 1
+/* MACROS FOR BACKWARDS COMPATIBILITY */
+/* structs */
+#define faacDecHandle                  NeAACDecHandle
+#define faacDecConfiguration           NeAACDecConfiguration
+#define faacDecConfigurationPtr        NeAACDecConfigurationPtr
+#define faacDecFrameInfo               NeAACDecFrameInfo
+/* functions */
+#define faacDecGetErrorMessage         NeAACDecGetErrorMessage
+#define faacDecSetConfiguration        NeAACDecSetConfiguration
+#define faacDecGetCurrentConfiguration NeAACDecGetCurrentConfiguration
+#define faacDecInit                    NeAACDecInit
+#define faacDecInit2                   NeAACDecInit2
+#define faacDecInitDRM                 NeAACDecInitDRM
+#define faacDecPostSeekReset           NeAACDecPostSeekReset
+#define faacDecOpen                    NeAACDecOpen
+#define faacDecClose                   NeAACDecClose
+#define faacDecDecode                  NeAACDecDecode
+#define AudioSpecificConfig            NeAACDecAudioSpecificConfig
+#endif
+
+
+#ifdef _WIN32
+  #pragma pack(push, 8)
+  #ifndef NEAACDECAPI
+    #define NEAACDECAPI __cdecl
+  #endif
+#else
+  #ifndef NEAACDECAPI
+    #define NEAACDECAPI
+  #endif
+#endif
+
+#define FAAD2_VERSION "2.7"
+
+/* object types for AAC */
+#define MAIN       1
+#define LC         2
+#define SSR        3
+#define LTP        4
+#define HE_AAC     5
+#define ER_LC     17
+#define ER_LTP    19
+#define LD        23
+#define DRM_ER_LC 27 /* special object type for DRM */
+
+/* header types */
+#define RAW        0
+#define ADIF       1
+#define ADTS       2
+#define LATM       3
+
+/* SBR signalling */
+#define NO_SBR           0
+#define SBR_UPSAMPLED    1
+#define SBR_DOWNSAMPLED  2
+#define NO_SBR_UPSAMPLED 3
+
+/* library output formats */
+#define FAAD_FMT_16BIT  1
+#define FAAD_FMT_24BIT  2
+#define FAAD_FMT_32BIT  3
+#define FAAD_FMT_FLOAT  4
+#define FAAD_FMT_FIXED  FAAD_FMT_FLOAT
+#define FAAD_FMT_DOUBLE 5
+
+/* Capabilities */
+#define LC_DEC_CAP           (1<<0) /* Can decode LC */
+#define MAIN_DEC_CAP         (1<<1) /* Can decode MAIN */
+#define LTP_DEC_CAP          (1<<2) /* Can decode LTP */
+#define LD_DEC_CAP           (1<<3) /* Can decode LD */
+#define ERROR_RESILIENCE_CAP (1<<4) /* Can decode ER */
+#define FIXED_POINT_CAP      (1<<5) /* Fixed point */
+
+/* Channel definitions */
+#define FRONT_CHANNEL_CENTER (1)
+#define FRONT_CHANNEL_LEFT   (2)
+#define FRONT_CHANNEL_RIGHT  (3)
+#define SIDE_CHANNEL_LEFT    (4)
+#define SIDE_CHANNEL_RIGHT   (5)
+#define BACK_CHANNEL_LEFT    (6)
+#define BACK_CHANNEL_RIGHT   (7)
+#define BACK_CHANNEL_CENTER  (8)
+#define LFE_CHANNEL          (9)
+#define UNKNOWN_CHANNEL      (0)
+
+/* DRM channel definitions */
+#define DRMCH_MONO          1
+#define DRMCH_STEREO        2
+#define DRMCH_SBR_MONO      3
+#define DRMCH_SBR_STEREO    4
+#define DRMCH_SBR_PS_STEREO 5
+
+
+/* A decode call can eat up to FAAD_MIN_STREAMSIZE bytes per decoded channel,
+   so at least so much bytes per channel should be available in this stream */
+#define FAAD_MIN_STREAMSIZE 768 /* 6144 bits/channel */
+
+
+typedef void *NeAACDecHandle;
+
+typedef struct mp4AudioSpecificConfig
+{
+    /* Audio Specific Info */
+    unsigned char objectTypeIndex;
+    unsigned char samplingFrequencyIndex;
+    unsigned long samplingFrequency;
+    unsigned char channelsConfiguration;
+
+    /* GA Specific Info */
+    unsigned char frameLengthFlag;
+    unsigned char dependsOnCoreCoder;
+    unsigned short coreCoderDelay;
+    unsigned char extensionFlag;
+    unsigned char aacSectionDataResilienceFlag;
+    unsigned char aacScalefactorDataResilienceFlag;
+    unsigned char aacSpectralDataResilienceFlag;
+    unsigned char epConfig;
+
+    char sbr_present_flag;
+    char forceUpSampling;
+    char downSampledSBR;
+} mp4AudioSpecificConfig;
+
+typedef struct NeAACDecConfiguration
+{
+    unsigned char defObjectType;
+    unsigned long defSampleRate;
+    unsigned char outputFormat;
+    unsigned char downMatrix;
+    unsigned char useOldADTSFormat;
+    unsigned char dontUpSampleImplicitSBR;
+} NeAACDecConfiguration, *NeAACDecConfigurationPtr;
+
+typedef struct NeAACDecFrameInfo
+{
+    unsigned long bytesconsumed;
+    unsigned long samples;
+    unsigned char channels;
+    unsigned char error;
+    unsigned long samplerate;
+
+    /* SBR: 0: off, 1: on; upsample, 2: on; downsampled, 3: off; upsampled */
+    unsigned char sbr;
+
+    /* MPEG-4 ObjectType */
+    unsigned char object_type;
+
+    /* AAC header type; MP4 will be signalled as RAW also */
+    unsigned char header_type;
+
+    /* multichannel configuration */
+    unsigned char num_front_channels;
+    unsigned char num_side_channels;
+    unsigned char num_back_channels;
+    unsigned char num_lfe_channels;
+    unsigned char channel_position[64];
+
+    /* PS: 0: off, 1: on */
+    unsigned char ps;
+} NeAACDecFrameInfo;
+
+char* NEAACDECAPI NeAACDecGetErrorMessage(unsigned char errcode);
+
+unsigned long NEAACDECAPI NeAACDecGetCapabilities(void);
+
+NeAACDecHandle NEAACDECAPI NeAACDecOpen(void);
+
+NeAACDecConfigurationPtr NEAACDECAPI NeAACDecGetCurrentConfiguration(NeAACDecHandle hDecoder);
+
+unsigned char NEAACDECAPI NeAACDecSetConfiguration(NeAACDecHandle hDecoder,
+                                                   NeAACDecConfigurationPtr config);
+
+/* Init the library based on info from the AAC file (ADTS/ADIF) */
+long NEAACDECAPI NeAACDecInit(NeAACDecHandle hDecoder,
+                              unsigned char *buffer,
+                              unsigned long buffer_size,
+                              unsigned long *samplerate,
+                              unsigned char *channels);
+
+/* Init the library using a DecoderSpecificInfo */
+char NEAACDECAPI NeAACDecInit2(NeAACDecHandle hDecoder,
+                               unsigned char *pBuffer,
+                               unsigned long SizeOfDecoderSpecificInfo,
+                               unsigned long *samplerate,
+                               unsigned char *channels);
+
+/* Init the library for DRM */
+char NEAACDECAPI NeAACDecInitDRM(NeAACDecHandle *hDecoder, unsigned long samplerate,
+                                 unsigned char channels);
+
+void NEAACDECAPI NeAACDecPostSeekReset(NeAACDecHandle hDecoder, long frame);
+
+void NEAACDECAPI NeAACDecClose(NeAACDecHandle hDecoder);
+
+void* NEAACDECAPI NeAACDecDecode(NeAACDecHandle hDecoder,
+                                 NeAACDecFrameInfo *hInfo,
+                                 unsigned char *buffer,
+                                 unsigned long buffer_size);
+
+void* NEAACDECAPI NeAACDecDecode2(NeAACDecHandle hDecoder,
+                                  NeAACDecFrameInfo *hInfo,
+                                  unsigned char *buffer,
+                                  unsigned long buffer_size,
+                                  void **sample_buffer,
+                                  unsigned long sample_buffer_size);
+
+char NEAACDECAPI NeAACDecAudioSpecificConfig(unsigned char *pBuffer,
+                                             unsigned long buffer_size,
+                                             mp4AudioSpecificConfig *mp4ASC);
+
+#ifdef _WIN32
+  #pragma pack(pop)
+#endif
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
--- ffmpeg-1.0/localinc/opencore-amrnb/interf_dec.h.dlopen~	2012-10-08 14:40:29.825299288 +0200
+++ ffmpeg-1.0/localinc/opencore-amrnb/interf_dec.h	2012-10-08 14:40:29.825299288 +0200
@@ -0,0 +1,34 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 2009 Martin Storsjo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+
+#ifndef OPENCORE_AMRNB_INTERF_DEC_H
+#define OPENCORE_AMRNB_INTERF_DEC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void* Decoder_Interface_init(void);
+void Decoder_Interface_exit(void* state);
+void Decoder_Interface_Decode(void* state, const unsigned char* in, short* out, int bfi);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- ffmpeg-1.0/localinc/opencore-amrnb/interf_enc.h.dlopen~	2012-10-08 14:40:29.825299288 +0200
+++ ffmpeg-1.0/localinc/opencore-amrnb/interf_enc.h	2012-10-08 14:40:29.825299288 +0200
@@ -0,0 +1,50 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 2009 Martin Storsjo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+
+#ifndef OPENCORE_AMRNB_INTERF_ENC_H
+#define OPENCORE_AMRNB_INTERF_ENC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef AMRNB_WRAPPER_INTERNAL
+/* Copied from enc/src/gsmamr_enc.h */
+enum Mode {
+	MR475 = 0,/* 4.75 kbps */
+	MR515,    /* 5.15 kbps */
+	MR59,     /* 5.90 kbps */
+	MR67,     /* 6.70 kbps */
+	MR74,     /* 7.40 kbps */
+	MR795,    /* 7.95 kbps */
+	MR102,    /* 10.2 kbps */
+	MR122,    /* 12.2 kbps */
+	MRDTX,    /* DTX       */
+	N_MODES   /* Not Used  */
+};
+#endif
+
+void* Encoder_Interface_init(int dtx);
+void Encoder_Interface_exit(void* state);
+int Encoder_Interface_Encode(void* state, enum Mode mode, const short* speech, unsigned char* out, int forceSpeech);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- ffmpeg-1.0/localinc/opencore-amrwb/dec_if.h.dlopen~	2012-10-08 14:40:29.841299284 +0200
+++ ffmpeg-1.0/localinc/opencore-amrwb/dec_if.h	2012-10-08 14:40:29.841299284 +0200
@@ -0,0 +1,36 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 2009 Martin Storsjo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+
+#ifndef OPENCORE_AMRWB_DEC_IF_H
+#define OPENCORE_AMRWB_DEC_IF_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define _good_frame 0
+
+void* D_IF_init(void);
+void D_IF_decode(void* state, const unsigned char* bits, short* synth, int bfi);
+void D_IF_exit(void* state);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- ffmpeg-1.0/localinc/opencore-amrwb/if_rom.h.dlopen~	2012-10-08 14:40:29.842299284 +0200
+++ ffmpeg-1.0/localinc/opencore-amrwb/if_rom.h	2012-10-08 14:40:29.842299284 +0200
@@ -0,0 +1,33 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 2009 Martin Storsjo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+
+#ifndef OPENCORE_AMRWB_IF_ROM_H
+#define OPENCORE_AMRWB_IF_ROM_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+typedef int16_t Word16;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- ffmpeg-1.0/localinc/x264_config.h.dlopen~	2012-10-08 14:40:29.842299284 +0200
+++ ffmpeg-1.0/localinc/x264_config.h	2012-10-08 14:40:29.842299284 +0200
@@ -0,0 +1,6 @@
+#define X264_BIT_DEPTH     8
+#define X264_GPL           1
+#define X264_INTERLACED    1
+#define X264_CHROMA_FORMAT 0
+#define X264_VERSION ""
+#define X264_POINTVER "0.120.x"
--- ffmpeg-1.0/localinc/x264.h.dlopen~	2012-10-08 14:40:29.842299284 +0200
+++ ffmpeg-1.0/localinc/x264.h	2012-10-08 14:40:29.842299284 +0200
@@ -0,0 +1,838 @@
+/*****************************************************************************
+ * x264.h: x264 public header
+ *****************************************************************************
+ * Copyright (C) 2003-2011 x264 project
+ *
+ * Authors: Laurent Aimar <fenrir@via.ecp.fr>
+ *          Loren Merritt <lorenm@u.washington.edu>
+ *          Jason Garrett-Glaser <darkshikari@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111, USA.
+ *
+ * This program is also available under a commercial proprietary license.
+ * For more information, contact us at licensing@x264.com.
+ *****************************************************************************/
+
+#ifndef X264_X264_H
+#define X264_X264_H
+
+#if !defined(_STDINT_H) && !defined(_STDINT_H_) && \
+    !defined(_INTTYPES_H) && !defined(_INTTYPES_H_)
+# ifdef _MSC_VER
+#  pragma message("You must include stdint.h or inttypes.h before x264.h")
+# else
+#  warning You must include stdint.h or inttypes.h before x264.h
+# endif
+#endif
+
+#include <stdarg.h>
+
+#include "x264_config.h"
+
+#define X264_BUILD 124
+
+/* x264_t:
+ *      opaque handler for encoder */
+typedef struct x264_t x264_t;
+
+/****************************************************************************
+ * NAL structure and functions
+ ****************************************************************************/
+
+enum nal_unit_type_e
+{
+    NAL_UNKNOWN     = 0,
+    NAL_SLICE       = 1,
+    NAL_SLICE_DPA   = 2,
+    NAL_SLICE_DPB   = 3,
+    NAL_SLICE_DPC   = 4,
+    NAL_SLICE_IDR   = 5,    /* ref_idc != 0 */
+    NAL_SEI         = 6,    /* ref_idc == 0 */
+    NAL_SPS         = 7,
+    NAL_PPS         = 8,
+    NAL_AUD         = 9,
+    NAL_FILLER      = 12,
+    /* ref_idc == 0 for 6,9,10,11,12 */
+};
+enum nal_priority_e
+{
+    NAL_PRIORITY_DISPOSABLE = 0,
+    NAL_PRIORITY_LOW        = 1,
+    NAL_PRIORITY_HIGH       = 2,
+    NAL_PRIORITY_HIGHEST    = 3,
+};
+
+/* The data within the payload is already NAL-encapsulated; the ref_idc and type
+ * are merely in the struct for easy access by the calling application.
+ * All data returned in an x264_nal_t, including the data in p_payload, is no longer
+ * valid after the next call to x264_encoder_encode.  Thus it must be used or copied
+ * before calling x264_encoder_encode or x264_encoder_headers again. */
+typedef struct
+{
+    int i_ref_idc;  /* nal_priority_e */
+    int i_type;     /* nal_unit_type_e */
+    int b_long_startcode;
+    int i_first_mb; /* If this NAL is a slice, the index of the first MB in the slice. */
+    int i_last_mb;  /* If this NAL is a slice, the index of the last MB in the slice. */
+
+    /* Size of payload in bytes. */
+    int     i_payload;
+    /* If param->b_annexb is set, Annex-B bytestream with startcode.
+     * Otherwise, startcode is replaced with a 4-byte size.
+     * This size is the size used in mp4/similar muxing; it is equal to i_payload-4 */
+    uint8_t *p_payload;
+} x264_nal_t;
+
+/****************************************************************************
+ * Encoder parameters
+ ****************************************************************************/
+/* CPU flags
+ */
+#define X264_CPU_CACHELINE_32    0x0000001  /* avoid memory loads that span the border between two cachelines */
+#define X264_CPU_CACHELINE_64    0x0000002  /* 32/64 is the size of a cacheline in bytes */
+#define X264_CPU_ALTIVEC         0x0000004
+#define X264_CPU_MMX             0x0000008
+#define X264_CPU_MMX2            0x0000010  /* MMX2 aka MMXEXT aka ISSE */
+#define X264_CPU_MMXEXT          X264_CPU_MMX2
+#define X264_CPU_SSE             0x0000020
+#define X264_CPU_SSE2            0x0000040
+#define X264_CPU_SSE2_IS_SLOW    0x0000080  /* avoid most SSE2 functions on Athlon64 */
+#define X264_CPU_SSE2_IS_FAST    0x0000100  /* a few functions are only faster on Core2 and Phenom */
+#define X264_CPU_SSE3            0x0000200
+#define X264_CPU_SSSE3           0x0000400
+#define X264_CPU_SHUFFLE_IS_FAST 0x0000800  /* Penryn, Nehalem, and Phenom have fast shuffle units */
+#define X264_CPU_STACK_MOD4      0x0001000  /* if stack is only mod4 and not mod16 */
+#define X264_CPU_SSE4            0x0002000  /* SSE4.1 */
+#define X264_CPU_SSE42           0x0004000  /* SSE4.2 */
+#define X264_CPU_SSE_MISALIGN    0x0008000  /* Phenom support for misaligned SSE instruction arguments */
+#define X264_CPU_LZCNT           0x0010000  /* Phenom support for "leading zero count" instruction. */
+#define X264_CPU_ARMV6           0x0020000
+#define X264_CPU_NEON            0x0040000  /* ARM NEON */
+#define X264_CPU_FAST_NEON_MRC   0x0080000  /* Transfer from NEON to ARM register is fast (Cortex-A9) */
+#define X264_CPU_SLOW_CTZ        0x0100000  /* BSR/BSF x86 instructions are really slow on some CPUs */
+#define X264_CPU_SLOW_ATOM       0x0200000  /* The Atom just sucks */
+#define X264_CPU_AVX             0x0400000  /* AVX support: requires OS support even if YMM registers
+                                             * aren't used. */
+#define X264_CPU_XOP             0x0800000  /* AMD XOP */
+#define X264_CPU_FMA4            0x1000000  /* AMD FMA4 */
+
+/* Analyse flags
+ */
+#define X264_ANALYSE_I4x4       0x0001  /* Analyse i4x4 */
+#define X264_ANALYSE_I8x8       0x0002  /* Analyse i8x8 (requires 8x8 transform) */
+#define X264_ANALYSE_PSUB16x16  0x0010  /* Analyse p16x8, p8x16 and p8x8 */
+#define X264_ANALYSE_PSUB8x8    0x0020  /* Analyse p8x4, p4x8, p4x4 */
+#define X264_ANALYSE_BSUB16x16  0x0100  /* Analyse b16x8, b8x16 and b8x8 */
+#define X264_DIRECT_PRED_NONE        0
+#define X264_DIRECT_PRED_SPATIAL     1
+#define X264_DIRECT_PRED_TEMPORAL    2
+#define X264_DIRECT_PRED_AUTO        3
+#define X264_ME_DIA                  0
+#define X264_ME_HEX                  1
+#define X264_ME_UMH                  2
+#define X264_ME_ESA                  3
+#define X264_ME_TESA                 4
+#define X264_CQM_FLAT                0
+#define X264_CQM_JVT                 1
+#define X264_CQM_CUSTOM              2
+#define X264_RC_CQP                  0
+#define X264_RC_CRF                  1
+#define X264_RC_ABR                  2
+#define X264_QP_AUTO                 0
+#define X264_AQ_NONE                 0
+#define X264_AQ_VARIANCE             1
+#define X264_AQ_AUTOVARIANCE         2
+#define X264_B_ADAPT_NONE            0
+#define X264_B_ADAPT_FAST            1
+#define X264_B_ADAPT_TRELLIS         2
+#define X264_WEIGHTP_NONE            0
+#define X264_WEIGHTP_SIMPLE          1
+#define X264_WEIGHTP_SMART           2
+#define X264_B_PYRAMID_NONE          0
+#define X264_B_PYRAMID_STRICT        1
+#define X264_B_PYRAMID_NORMAL        2
+#define X264_KEYINT_MIN_AUTO         0
+#define X264_KEYINT_MAX_INFINITE     (1<<30)
+
+static const char * const x264_direct_pred_names[] = { "none", "spatial", "temporal", "auto", 0 };
+static const char * const x264_motion_est_names[] = { "dia", "hex", "umh", "esa", "tesa", 0 };
+static const char * const x264_b_pyramid_names[] = { "none", "strict", "normal", 0 };
+static const char * const x264_overscan_names[] = { "undef", "show", "crop", 0 };
+static const char * const x264_vidformat_names[] = { "component", "pal", "ntsc", "secam", "mac", "undef", 0 };
+static const char * const x264_fullrange_names[] = { "off", "on", 0 };
+static const char * const x264_colorprim_names[] = { "", "bt709", "undef", "", "bt470m", "bt470bg", "smpte170m", "smpte240m", "film", 0 };
+static const char * const x264_transfer_names[] = { "", "bt709", "undef", "", "bt470m", "bt470bg", "smpte170m", "smpte240m", "linear", "log100", "log316", 0 };
+static const char * const x264_colmatrix_names[] = { "GBR", "bt709", "undef", "", "fcc", "bt470bg", "smpte170m", "smpte240m", "YCgCo", 0 };
+static const char * const x264_nal_hrd_names[] = { "none", "vbr", "cbr", 0 };
+
+/* Colorspace type */
+#define X264_CSP_MASK           0x00ff  /* */
+#define X264_CSP_NONE           0x0000  /* Invalid mode     */
+#define X264_CSP_I420           0x0001  /* yuv 4:2:0 planar */
+#define X264_CSP_YV12           0x0002  /* yvu 4:2:0 planar */
+#define X264_CSP_NV12           0x0003  /* yuv 4:2:0, with one y plane and one packed u+v */
+#define X264_CSP_I422           0x0004  /* yuv 4:2:2 planar */
+#define X264_CSP_YV16           0x0005  /* yvu 4:2:2 planar */
+#define X264_CSP_NV16           0x0006  /* yuv 4:2:2, with one y plane and one packed u+v */
+#define X264_CSP_I444           0x0007  /* yuv 4:4:4 planar */
+#define X264_CSP_YV24           0x0008  /* yvu 4:4:4 planar */
+#define X264_CSP_BGR            0x0009  /* packed bgr 24bits   */
+#define X264_CSP_BGRA           0x000a  /* packed bgr 32bits   */
+#define X264_CSP_RGB            0x000b  /* packed rgb 24bits   */
+#define X264_CSP_MAX            0x000c  /* end of list */
+#define X264_CSP_VFLIP          0x1000  /* the csp is vertically flipped */
+#define X264_CSP_HIGH_DEPTH     0x2000  /* the csp has a depth of 16 bits per pixel component */
+
+/* Slice type */
+#define X264_TYPE_AUTO          0x0000  /* Let x264 choose the right type */
+#define X264_TYPE_IDR           0x0001
+#define X264_TYPE_I             0x0002
+#define X264_TYPE_P             0x0003
+#define X264_TYPE_BREF          0x0004  /* Non-disposable B-frame */
+#define X264_TYPE_B             0x0005
+#define X264_TYPE_KEYFRAME      0x0006  /* IDR or I depending on b_open_gop option */
+#define IS_X264_TYPE_I(x) ((x)==X264_TYPE_I || (x)==X264_TYPE_IDR)
+#define IS_X264_TYPE_B(x) ((x)==X264_TYPE_B || (x)==X264_TYPE_BREF)
+
+/* Log level */
+#define X264_LOG_NONE          (-1)
+#define X264_LOG_ERROR          0
+#define X264_LOG_WARNING        1
+#define X264_LOG_INFO           2
+#define X264_LOG_DEBUG          3
+
+/* Threading */
+#define X264_THREADS_AUTO 0 /* Automatically select optimal number of threads */
+#define X264_SYNC_LOOKAHEAD_AUTO (-1) /* Automatically select optimal lookahead thread buffer size */
+
+/* HRD */
+#define X264_NAL_HRD_NONE            0
+#define X264_NAL_HRD_VBR             1
+#define X264_NAL_HRD_CBR             2
+
+/* Zones: override ratecontrol or other options for specific sections of the video.
+ * See x264_encoder_reconfig() for which options can be changed.
+ * If zones overlap, whichever comes later in the list takes precedence. */
+typedef struct
+{
+    int i_start, i_end; /* range of frame numbers */
+    int b_force_qp; /* whether to use qp vs bitrate factor */
+    int i_qp;
+    float f_bitrate_factor;
+    struct x264_param_t *param;
+} x264_zone_t;
+
+typedef struct x264_param_t
+{
+    /* CPU flags */
+    unsigned int cpu;
+    int         i_threads;       /* encode multiple frames in parallel */
+    int         b_sliced_threads;  /* Whether to use slice-based threading. */
+    int         b_deterministic; /* whether to allow non-deterministic optimizations when threaded */
+    int         b_cpu_independent; /* force canonical behavior rather than cpu-dependent optimal algorithms */
+    int         i_sync_lookahead; /* threaded lookahead buffer */
+
+    /* Video Properties */
+    int         i_width;
+    int         i_height;
+    int         i_csp;         /* CSP of encoded bitstream */
+    int         i_level_idc;
+    int         i_frame_total; /* number of frames to encode if known, else 0 */
+
+    /* NAL HRD
+     * Uses Buffering and Picture Timing SEIs to signal HRD
+     * The HRD in H.264 was not designed with VFR in mind.
+     * It is therefore not recommendeded to use NAL HRD with VFR.
+     * Furthermore, reconfiguring the VBV (via x264_encoder_reconfig)
+     * will currently generate invalid HRD. */
+    int         i_nal_hrd;
+
+    struct
+    {
+        /* they will be reduced to be 0 < x <= 65535 and prime */
+        int         i_sar_height;
+        int         i_sar_width;
+
+        int         i_overscan;    /* 0=undef, 1=no overscan, 2=overscan */
+
+        /* see h264 annex E for the values of the following */
+        int         i_vidformat;
+        int         b_fullrange;
+        int         i_colorprim;
+        int         i_transfer;
+        int         i_colmatrix;
+        int         i_chroma_loc;    /* both top & bottom */
+    } vui;
+
+    /* Bitstream parameters */
+    int         i_frame_reference;  /* Maximum number of reference frames */
+    int         i_dpb_size;         /* Force a DPB size larger than that implied by B-frames and reference frames.
+                                     * Useful in combination with interactive error resilience. */
+    int         i_keyint_max;       /* Force an IDR keyframe at this interval */
+    int         i_keyint_min;       /* Scenecuts closer together than this are coded as I, not IDR. */
+    int         i_scenecut_threshold; /* how aggressively to insert extra I frames */
+    int         b_intra_refresh;    /* Whether or not to use periodic intra refresh instead of IDR frames. */
+
+    int         i_bframe;   /* how many b-frame between 2 references pictures */
+    int         i_bframe_adaptive;
+    int         i_bframe_bias;
+    int         i_bframe_pyramid;   /* Keep some B-frames as references: 0=off, 1=strict hierarchical, 2=normal */
+    int         b_open_gop;
+    int         b_bluray_compat;
+
+    int         b_deblocking_filter;
+    int         i_deblocking_filter_alphac0;    /* [-6, 6] -6 light filter, 6 strong */
+    int         i_deblocking_filter_beta;       /* [-6, 6]  idem */
+
+    int         b_cabac;
+    int         i_cabac_init_idc;
+
+    int         b_interlaced;
+    int         b_constrained_intra;
+
+    int         i_cqm_preset;
+    char        *psz_cqm_file;      /* JM format */
+    uint8_t     cqm_4iy[16];        /* used only if i_cqm_preset == X264_CQM_CUSTOM */
+    uint8_t     cqm_4py[16];
+    uint8_t     cqm_4ic[16];
+    uint8_t     cqm_4pc[16];
+    uint8_t     cqm_8iy[64];
+    uint8_t     cqm_8py[64];
+    uint8_t     cqm_8ic[64];
+    uint8_t     cqm_8pc[64];
+
+    /* Log */
+    void        (*pf_log)( void *, int i_level, const char *psz, va_list );
+    void        *p_log_private;
+    int         i_log_level;
+    int         b_visualize;
+    char        *psz_dump_yuv;  /* filename for reconstructed frames */
+
+    /* Encoder analyser parameters */
+    struct
+    {
+        unsigned int intra;     /* intra partitions */
+        unsigned int inter;     /* inter partitions */
+
+        int          b_transform_8x8;
+        int          i_weighted_pred; /* weighting for P-frames */
+        int          b_weighted_bipred; /* implicit weighting for B-frames */
+        int          i_direct_mv_pred; /* spatial vs temporal mv prediction */
+        int          i_chroma_qp_offset;
+
+        int          i_me_method; /* motion estimation algorithm to use (X264_ME_*) */
+        int          i_me_range; /* integer pixel motion estimation search range (from predicted mv) */
+        int          i_mv_range; /* maximum length of a mv (in pixels). -1 = auto, based on level */
+        int          i_mv_range_thread; /* minimum space between threads. -1 = auto, based on number of threads. */
+        int          i_subpel_refine; /* subpixel motion estimation quality */
+        int          b_chroma_me; /* chroma ME for subpel and mode decision in P-frames */
+        int          b_mixed_references; /* allow each mb partition to have its own reference number */
+        int          i_trellis;  /* trellis RD quantization */
+        int          b_fast_pskip; /* early SKIP detection on P-frames */
+        int          b_dct_decimate; /* transform coefficient thresholding on P-frames */
+        int          i_noise_reduction; /* adaptive pseudo-deadzone */
+        float        f_psy_rd; /* Psy RD strength */
+        float        f_psy_trellis; /* Psy trellis strength */
+        int          b_psy; /* Toggle all psy optimizations */
+
+        /* the deadzone size that will be used in luma quantization */
+        int          i_luma_deadzone[2]; /* {inter, intra} */
+
+        int          b_psnr;    /* compute and print PSNR stats */
+        int          b_ssim;    /* compute and print SSIM stats */
+    } analyse;
+
+    /* Rate control parameters */
+    struct
+    {
+        int         i_rc_method;    /* X264_RC_* */
+
+        int         i_qp_constant;  /* 0 to (51 + 6*(x264_bit_depth-8)). 0=lossless */
+        int         i_qp_min;       /* min allowed QP value */
+        int         i_qp_max;       /* max allowed QP value */
+        int         i_qp_step;      /* max QP step between frames */
+
+        int         i_bitrate;
+        float       f_rf_constant;  /* 1pass VBR, nominal QP */
+        float       f_rf_constant_max;  /* In CRF mode, maximum CRF as caused by VBV */
+        float       f_rate_tolerance;
+        int         i_vbv_max_bitrate;
+        int         i_vbv_buffer_size;
+        float       f_vbv_buffer_init; /* <=1: fraction of buffer_size. >1: kbit */
+        float       f_ip_factor;
+        float       f_pb_factor;
+
+        int         i_aq_mode;      /* psy adaptive QP. (X264_AQ_*) */
+        float       f_aq_strength;
+        int         b_mb_tree;      /* Macroblock-tree ratecontrol. */
+        int         i_lookahead;
+
+        /* 2pass */
+        int         b_stat_write;   /* Enable stat writing in psz_stat_out */
+        char        *psz_stat_out;
+        int         b_stat_read;    /* Read stat from psz_stat_in and use it */
+        char        *psz_stat_in;
+
+        /* 2pass params (same as ffmpeg ones) */
+        float       f_qcompress;    /* 0.0 => cbr, 1.0 => constant qp */
+        float       f_qblur;        /* temporally blur quants */
+        float       f_complexity_blur; /* temporally blur complexity */
+        x264_zone_t *zones;         /* ratecontrol overrides */
+        int         i_zones;        /* number of zone_t's */
+        char        *psz_zones;     /* alternate method of specifying zones */
+    } rc;
+
+    /* Cropping Rectangle parameters: added to those implicitly defined by
+       non-mod16 video resolutions. */
+    struct
+    {
+        unsigned int i_left;
+        unsigned int i_top;
+        unsigned int i_right;
+        unsigned int i_bottom;
+    } crop_rect;
+
+    /* frame packing arrangement flag */
+    int i_frame_packing;
+
+    /* Muxing parameters */
+    int b_aud;                  /* generate access unit delimiters */
+    int b_repeat_headers;       /* put SPS/PPS before each keyframe */
+    int b_annexb;               /* if set, place start codes (4 bytes) before NAL units,
+                                 * otherwise place size (4 bytes) before NAL units. */
+    int i_sps_id;               /* SPS and PPS id number */
+    int b_vfr_input;            /* VFR input.  If 1, use timebase and timestamps for ratecontrol purposes.
+                                 * If 0, use fps only. */
+    int b_pulldown;             /* use explicity set timebase for CFR */
+    uint32_t i_fps_num;
+    uint32_t i_fps_den;
+    uint32_t i_timebase_num;    /* Timebase numerator */
+    uint32_t i_timebase_den;    /* Timebase denominator */
+
+    int b_tff;
+
+    /* Pulldown:
+     * The correct pic_struct must be passed with each input frame.
+     * The input timebase should be the timebase corresponding to the output framerate. This should be constant.
+     * e.g. for 3:2 pulldown timebase should be 1001/30000
+     * The PTS passed with each frame must be the PTS of the frame after pulldown is applied.
+     * Frame doubling and tripling require b_vfr_input set to zero (see H.264 Table D-1)
+     *
+     * Pulldown changes are not clearly defined in H.264. Therefore, it is the calling app's responsibility to manage this.
+     */
+
+    int b_pic_struct;
+
+    /* Fake Interlaced.
+     *
+     * Used only when b_interlaced=0. Setting this flag makes it possible to flag the stream as PAFF interlaced yet
+     * encode all frames progessively. It is useful for encoding 25p and 30p Blu-Ray streams.
+     */
+
+    int b_fake_interlaced;
+
+    /* Slicing parameters */
+    int i_slice_max_size;    /* Max size per slice in bytes; includes estimated NAL overhead. */
+    int i_slice_max_mbs;     /* Max number of MBs per slice; overrides i_slice_count. */
+    int i_slice_count;       /* Number of slices per frame: forces rectangular slices. */
+
+    /* Optional callback for freeing this x264_param_t when it is done being used.
+     * Only used when the x264_param_t sits in memory for an indefinite period of time,
+     * i.e. when an x264_param_t is passed to x264_t in an x264_picture_t or in zones.
+     * Not used when x264_encoder_reconfig is called directly. */
+    void (*param_free)( void* );
+
+    /* Optional low-level callback for low-latency encoding.  Called for each output NAL unit
+     * immediately after the NAL unit is finished encoding.  This allows the calling application
+     * to begin processing video data (e.g. by sending packets over a network) before the frame
+     * is done encoding.
+     *
+     * This callback MUST do the following in order to work correctly:
+     * 1) Have available an output buffer of at least size nal->i_payload*3/2 + 5 + 16.
+     * 2) Call x264_nal_encode( h, dst, nal ), where dst is the output buffer.
+     * After these steps, the content of nal is valid and can be used in the same way as if
+     * the NAL unit were output by x264_encoder_encode.
+     *
+     * This does not need to be synchronous with the encoding process: the data pointed to
+     * by nal (both before and after x264_nal_encode) will remain valid until the next
+     * x264_encoder_encode call.  The callback must be re-entrant.
+     *
+     * This callback does not work with frame-based threads; threads must be disabled
+     * or sliced-threads enabled.  This callback also does not work as one would expect
+     * with HRD -- since the buffering period SEI cannot be calculated until the frame
+     * is finished encoding, it will not be sent via this callback.
+     *
+     * Note also that the NALs are not necessarily returned in order when sliced threads is
+     * enabled.  Accordingly, the variable i_first_mb and i_last_mb are available in
+     * x264_nal_t to help the calling application reorder the slices if necessary.
+     *
+     * When this callback is enabled, x264_encoder_encode does not return valid NALs;
+     * the calling application is expected to acquire all output NALs through the callback.
+     *
+     * It is generally sensible to combine this callback with a use of slice-max-mbs or
+     * slice-max-size. */
+    void (*nalu_process) ( x264_t *h, x264_nal_t *nal );
+} x264_param_t;
+
+void x264_nal_encode( x264_t *h, uint8_t *dst, x264_nal_t *nal );
+
+/****************************************************************************
+ * H.264 level restriction information
+ ****************************************************************************/
+
+typedef struct
+{
+    int level_idc;
+    int mbps;        /* max macroblock processing rate (macroblocks/sec) */
+    int frame_size;  /* max frame size (macroblocks) */
+    int dpb;         /* max decoded picture buffer (bytes) */
+    int bitrate;     /* max bitrate (kbit/sec) */
+    int cpb;         /* max vbv buffer (kbit) */
+    int mv_range;    /* max vertical mv component range (pixels) */
+    int mvs_per_2mb; /* max mvs per 2 consecutive mbs. */
+    int slice_rate;  /* ?? */
+    int mincr;       /* min compression ratio */
+    int bipred8x8;   /* limit bipred to >=8x8 */
+    int direct8x8;   /* limit b_direct to >=8x8 */
+    int frame_only;  /* forbid interlacing */
+} x264_level_t;
+
+/* all of the levels defined in the standard, terminated by .level_idc=0 */
+extern const x264_level_t x264_levels[];
+
+/****************************************************************************
+ * Basic parameter handling functions
+ ****************************************************************************/
+
+/* x264_param_default:
+ *      fill x264_param_t with default values and do CPU detection */
+void    x264_param_default( x264_param_t * );
+
+/* x264_param_parse:
+ *  set one parameter by name.
+ *  returns 0 on success, or returns one of the following errors.
+ *  note: BAD_VALUE occurs only if it can't even parse the value,
+ *  numerical range is not checked until x264_encoder_open() or
+ *  x264_encoder_reconfig().
+ *  value=NULL means "true" for boolean options, but is a BAD_VALUE for non-booleans. */
+#define X264_PARAM_BAD_NAME  (-1)
+#define X264_PARAM_BAD_VALUE (-2)
+int x264_param_parse( x264_param_t *, const char *name, const char *value );
+
+/****************************************************************************
+ * Advanced parameter handling functions
+ ****************************************************************************/
+
+/* These functions expose the full power of x264's preset-tune-profile system for
+ * easy adjustment of large numbers of internal parameters.
+ *
+ * In order to replicate x264CLI's option handling, these functions MUST be called
+ * in the following order:
+ * 1) x264_param_default_preset
+ * 2) Custom user options (via param_parse or directly assigned variables)
+ * 3) x264_param_apply_fastfirstpass
+ * 4) x264_param_apply_profile
+ *
+ * Additionally, x264CLI does not apply step 3 if the preset chosen is "placebo"
+ * or --slow-firstpass is set. */
+
+/* x264_param_default_preset:
+ *      The same as x264_param_default, but also use the passed preset and tune
+ *      to modify the default settings.
+ *      (either can be NULL, which implies no preset or no tune, respectively)
+ *
+ *      Currently available presets are, ordered from fastest to slowest: */
+static const char * const x264_preset_names[] = { "ultrafast", "superfast", "veryfast", "faster", "fast", "medium", "slow", "slower", "veryslow", "placebo", 0 };
+
+/*      The presets can also be indexed numerically, as in:
+ *      x264_param_default_preset( &param, "3", ... )
+ *      with ultrafast mapping to "0" and placebo mapping to "9".  This mapping may
+ *      of course change if new presets are added in between, but will always be
+ *      ordered from fastest to slowest.
+ *
+ *      Warning: the speed of these presets scales dramatically.  Ultrafast is a full
+ *      100 times faster than placebo!
+ *
+ *      Currently available tunings are: */
+static const char * const x264_tune_names[] = { "film", "animation", "grain", "stillimage", "psnr", "ssim", "fastdecode", "zerolatency", 0 };
+
+/*      Multiple tunings can be used if separated by a delimiter in ",./-+",
+ *      however multiple psy tunings cannot be used.
+ *      film, animation, grain, stillimage, psnr, and ssim are psy tunings.
+ *
+ *      returns 0 on success, negative on failure (e.g. invalid preset/tune name). */
+int     x264_param_default_preset( x264_param_t *, const char *preset, const char *tune );
+
+/* x264_param_apply_fastfirstpass:
+ *      If first-pass mode is set (rc.b_stat_read == 0, rc.b_stat_write == 1),
+ *      modify the encoder settings to disable options generally not useful on
+ *      the first pass. */
+void    x264_param_apply_fastfirstpass( x264_param_t * );
+
+/* x264_param_apply_profile:
+ *      Applies the restrictions of the given profile.
+ *      Currently available profiles are, from most to least restrictive: */
+static const char * const x264_profile_names[] = { "baseline", "main", "high", "high10", "high422", "high444", 0 };
+
+/*      (can be NULL, in which case the function will do nothing)
+ *
+ *      Does NOT guarantee that the given profile will be used: if the restrictions
+ *      of "High" are applied to settings that are already Baseline-compatible, the
+ *      stream will remain baseline.  In short, it does not increase settings, only
+ *      decrease them.
+ *
+ *      returns 0 on success, negative on failure (e.g. invalid profile name). */
+int     x264_param_apply_profile( x264_param_t *, const char *profile );
+
+/****************************************************************************
+ * Picture structures and functions
+ ****************************************************************************/
+
+/* x264_bit_depth:
+ *      Specifies the number of bits per pixel that x264 uses. This is also the
+ *      bit depth that x264 encodes in. If this value is > 8, x264 will read
+ *      two bytes of input data for each pixel sample, and expect the upper
+ *      (16-x264_bit_depth) bits to be zero.
+ *      Note: The flag X264_CSP_HIGH_DEPTH must be used to specify the
+ *      colorspace depth as well. */
+extern const int x264_bit_depth;
+
+/* x264_chroma_format:
+ *      Specifies the chroma formats that x264 supports encoding. When this
+ *      value is non-zero, then it represents a X264_CSP_* that is the only
+ *      chroma format that x264 supports encoding. If the value is 0 then
+ *      there are no restrictions. */
+extern const int x264_chroma_format;
+
+enum pic_struct_e
+{
+    PIC_STRUCT_AUTO              = 0, // automatically decide (default)
+    PIC_STRUCT_PROGRESSIVE       = 1, // progressive frame
+    // "TOP" and "BOTTOM" are not supported in x264 (PAFF only)
+    PIC_STRUCT_TOP_BOTTOM        = 4, // top field followed by bottom
+    PIC_STRUCT_BOTTOM_TOP        = 5, // bottom field followed by top
+    PIC_STRUCT_TOP_BOTTOM_TOP    = 6, // top field, bottom field, top field repeated
+    PIC_STRUCT_BOTTOM_TOP_BOTTOM = 7, // bottom field, top field, bottom field repeated
+    PIC_STRUCT_DOUBLE            = 8, // double frame
+    PIC_STRUCT_TRIPLE            = 9, // triple frame
+};
+
+typedef struct
+{
+    double cpb_initial_arrival_time;
+    double cpb_final_arrival_time;
+    double cpb_removal_time;
+
+    double dpb_output_time;
+} x264_hrd_t;
+
+/* Arbitrary user SEI:
+ * Payload size is in bytes and the payload pointer must be valid.
+ * Payload types and syntax can be found in Annex D of the H.264 Specification.
+ * SEI payload alignment bits as described in Annex D must be included at the
+ * end of the payload if needed.
+ * The payload should not be NAL-encapsulated.
+ * Payloads are written first in order of input, apart from in the case when HRD
+ * is enabled where payloads are written after the Buffering Period SEI. */
+
+typedef struct
+{
+    int payload_size;
+    int payload_type;
+    uint8_t *payload;
+} x264_sei_payload_t;
+
+typedef struct
+{
+    int num_payloads;
+    x264_sei_payload_t *payloads;
+    /* In: optional callback to free each payload AND x264_sei_payload_t when used. */
+    void (*sei_free)( void* );
+} x264_sei_t;
+
+typedef struct
+{
+    int     i_csp;       /* Colorspace */
+    int     i_plane;     /* Number of image planes */
+    int     i_stride[4]; /* Strides for each plane */
+    uint8_t *plane[4];   /* Pointers to each plane */
+} x264_image_t;
+
+typedef struct
+{
+    /* In: an array of quantizer offsets to be applied to this image during encoding.
+     *     These are added on top of the decisions made by x264.
+     *     Offsets can be fractional; they are added before QPs are rounded to integer.
+     *     Adaptive quantization must be enabled to use this feature.  Behavior if quant
+     *     offsets differ between encoding passes is undefined.
+     *
+     *     Array contains one offset per macroblock, in raster scan order.  In interlaced
+     *     mode, top-field MBs and bottom-field MBs are interleaved at the row level. */
+    float *quant_offsets;
+    /* In: optional callback to free quant_offsets when used.
+     *     Useful if one wants to use a different quant_offset array for each frame. */
+    void (*quant_offsets_free)( void* );
+} x264_image_properties_t;
+
+typedef struct
+{
+    /* In: force picture type (if not auto)
+     *     If x264 encoding parameters are violated in the forcing of picture types,
+     *     x264 will correct the input picture type and log a warning.
+     *     The quality of frametype decisions may suffer if a great deal of fine-grained
+     *     mixing of auto and forced frametypes is done.
+     * Out: type of the picture encoded */
+    int     i_type;
+    /* In: force quantizer for != X264_QP_AUTO */
+    int     i_qpplus1;
+    /* In: pic_struct, for pulldown/doubling/etc...used only if b_pic_struct=1.
+     *     use pic_struct_e for pic_struct inputs
+     * Out: pic_struct element associated with frame */
+    int     i_pic_struct;
+    /* Out: whether this frame is a keyframe.  Important when using modes that result in
+     * SEI recovery points being used instead of IDR frames. */
+    int     b_keyframe;
+    /* In: user pts, Out: pts of encoded picture (user)*/
+    int64_t i_pts;
+    /* Out: frame dts. When the pts of the first frame is close to zero,
+     *      initial frames may have a negative dts which must be dealt with by any muxer */
+    int64_t i_dts;
+    /* In: custom encoding parameters to be set from this frame forwards
+           (in coded order, not display order). If NULL, continue using
+           parameters from the previous frame.  Some parameters, such as
+           aspect ratio, can only be changed per-GOP due to the limitations
+           of H.264 itself; in this case, the caller must force an IDR frame
+           if it needs the changed parameter to apply immediately. */
+    x264_param_t *param;
+    /* In: raw data */
+    x264_image_t img;
+    /* In: optional information to modify encoder decisions for this frame */
+    x264_image_properties_t prop;
+    /* Out: HRD timing information. Output only when i_nal_hrd is set. */
+    x264_hrd_t hrd_timing;
+    /* In: arbitrary user SEI (e.g subtitles, AFDs) */
+    x264_sei_t extra_sei;
+    /* private user data. copied from input to output frames. */
+    void *opaque;
+} x264_picture_t;
+
+/* x264_picture_init:
+ *  initialize an x264_picture_t.  Needs to be done if the calling application
+ *  allocates its own x264_picture_t as opposed to using x264_picture_alloc. */
+void x264_picture_init( x264_picture_t *pic );
+
+/* x264_picture_alloc:
+ *  alloc data for a picture. You must call x264_picture_clean on it.
+ *  returns 0 on success, or -1 on malloc failure or invalid colorspace. */
+int x264_picture_alloc( x264_picture_t *pic, int i_csp, int i_width, int i_height );
+
+/* x264_picture_clean:
+ *  free associated resource for a x264_picture_t allocated with
+ *  x264_picture_alloc ONLY */
+void x264_picture_clean( x264_picture_t *pic );
+
+/****************************************************************************
+ * Encoder functions
+ ****************************************************************************/
+
+/* Force a link error in the case of linking against an incompatible API version.
+ * Glue #defines exist to force correct macro expansion; the final output of the macro
+ * is x264_encoder_open_##X264_BUILD (for purposes of dlopen). */
+#define x264_encoder_glue1(x,y) x##y
+#define x264_encoder_glue2(x,y) x264_encoder_glue1(x,y)
+#define x264_encoder_open x264_encoder_glue2(x264_encoder_open_,X264_BUILD)
+
+/* x264_encoder_open:
+ *      create a new encoder handler, all parameters from x264_param_t are copied */
+x264_t *x264_encoder_open( x264_param_t * );
+
+/* x264_encoder_reconfig:
+ *      various parameters from x264_param_t are copied.
+ *      this takes effect immediately, on whichever frame is encoded next;
+ *      due to delay, this may not be the next frame passed to encoder_encode.
+ *      if the change should apply to some particular frame, use x264_picture_t->param instead.
+ *      returns 0 on success, negative on parameter validation error.
+ *      not all parameters can be changed; see the actual function for a detailed breakdown. */
+int     x264_encoder_reconfig( x264_t *, x264_param_t * );
+/* x264_encoder_parameters:
+ *      copies the current internal set of parameters to the pointer provided
+ *      by the caller.  useful when the calling application needs to know
+ *      how x264_encoder_open has changed the parameters, or the current state
+ *      of the encoder after multiple x264_encoder_reconfig calls.
+ *      note that the data accessible through pointers in the returned param struct
+ *      (e.g. filenames) should not be modified by the calling application. */
+void    x264_encoder_parameters( x264_t *, x264_param_t * );
+/* x264_encoder_headers:
+ *      return the SPS and PPS that will be used for the whole stream.
+ *      *pi_nal is the number of NAL units outputted in pp_nal.
+ *      returns negative on error.
+ *      the payloads of all output NALs are guaranteed to be sequential in memory. */
+int     x264_encoder_headers( x264_t *, x264_nal_t **pp_nal, int *pi_nal );
+/* x264_encoder_encode:
+ *      encode one picture.
+ *      *pi_nal is the number of NAL units outputted in pp_nal.
+ *      returns negative on error, zero if no NAL units returned.
+ *      the payloads of all output NALs are guaranteed to be sequential in memory. */
+int     x264_encoder_encode( x264_t *, x264_nal_t **pp_nal, int *pi_nal, x264_picture_t *pic_in, x264_picture_t *pic_out );
+/* x264_encoder_close:
+ *      close an encoder handler */
+void    x264_encoder_close  ( x264_t * );
+/* x264_encoder_delayed_frames:
+ *      return the number of currently delayed (buffered) frames
+ *      this should be used at the end of the stream, to know when you have all the encoded frames. */
+int     x264_encoder_delayed_frames( x264_t * );
+/* x264_encoder_maximum_delayed_frames( x264_t *h ):
+ *      return the maximum number of delayed (buffered) frames that can occur with the current
+ *      parameters. */
+int     x264_encoder_maximum_delayed_frames( x264_t *h );
+/* x264_encoder_intra_refresh:
+ *      If an intra refresh is not in progress, begin one with the next P-frame.
+ *      If an intra refresh is in progress, begin one as soon as the current one finishes.
+ *      Requires that b_intra_refresh be set.
+ *
+ *      Useful for interactive streaming where the client can tell the server that packet loss has
+ *      occurred.  In this case, keyint can be set to an extremely high value so that intra refreshes
+ *      only occur when calling x264_encoder_intra_refresh.
+ *
+ *      In multi-pass encoding, if x264_encoder_intra_refresh is called differently in each pass,
+ *      behavior is undefined.
+ *
+ *      Should not be called during an x264_encoder_encode. */
+void    x264_encoder_intra_refresh( x264_t * );
+/* x264_encoder_invalidate_reference:
+ *      An interactive error resilience tool, designed for use in a low-latency one-encoder-few-clients
+ *      system.  When the client has packet loss or otherwise incorrectly decodes a frame, the encoder
+ *      can be told with this command to "forget" the frame and all frames that depend on it, referencing
+ *      only frames that occurred before the loss.  This will force a keyframe if no frames are left to
+ *      reference after the aforementioned "forgetting".
+ *
+ *      It is strongly recommended to use a large i_dpb_size in this case, which allows the encoder to
+ *      keep around extra, older frames to fall back on in case more recent frames are all invalidated.
+ *      Unlike increasing i_frame_reference, this does not increase the number of frames used for motion
+ *      estimation and thus has no speed impact.  It is also recommended to set a very large keyframe
+ *      interval, so that keyframes are not used except as necessary for error recovery.
+ *
+ *      x264_encoder_invalidate_reference is not currently compatible with the use of B-frames or intra
+ *      refresh.
+ *
+ *      In multi-pass encoding, if x264_encoder_invalidate_reference is called differently in each pass,
+ *      behavior is undefined.
+ *
+ *      Should not be called during an x264_encoder_encode, but multiple calls can be made simultaneously.
+ *
+ *      Returns 0 on success, negative on failure. */
+int x264_encoder_invalidate_reference( x264_t *, int64_t pts );
+
+#endif
--- ffmpeg-1.0/localinc/xvid.h.dlopen~	2012-10-08 14:40:29.843299284 +0200
+++ ffmpeg-1.0/localinc/xvid.h	2012-10-08 14:40:29.843299284 +0200
@@ -0,0 +1,830 @@
+/*****************************************************************************
+ *
+ * XVID MPEG-4 VIDEO CODEC
+ * - Xvid Main header file -
+ *
+ *  Copyright(C) 2001-2011 Peter Ross <pross@xvid.org>
+ *
+ *  This program is free software ; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation ; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY ; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program ; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * $Id: xvid.h 1985 2011-05-18 09:02:35Z Isibaar $
+ *
+ ****************************************************************************/
+
+#ifndef _XVID_H_
+#define _XVID_H_
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*****************************************************************************
+ * versioning
+ ****************************************************************************/
+
+/* versioning
+	version takes the form "$major.$minor.$patch"
+	$patch is incremented when there is no api change
+	$minor is incremented when the api is changed, but remains backwards compatible
+	$major is incremented when the api is changed significantly
+
+	when initialising an xvid structure, you must always zero it, and set the version field.
+		memset(&struct,0,sizeof(struct));
+		struct.version = XVID_VERSION;
+
+	XVID_UNSTABLE is defined only during development.
+	*/
+
+#define XVID_MAKE_VERSION(a,b,c) ((((a)&0xff)<<16) | (((b)&0xff)<<8) | ((c)&0xff))
+#define XVID_VERSION_MAJOR(a)    ((char)(((a)>>16) & 0xff))
+#define XVID_VERSION_MINOR(a)    ((char)(((a)>> 8) & 0xff))
+#define XVID_VERSION_PATCH(a)    ((char)(((a)>> 0) & 0xff))
+
+#define XVID_MAKE_API(a,b)       ((((a)&0xff)<<16) | (((b)&0xff)<<0))
+#define XVID_API_MAJOR(a)        (((a)>>16) & 0xff)
+#define XVID_API_MINOR(a)        (((a)>> 0) & 0xff)
+
+#define XVID_VERSION             XVID_MAKE_VERSION(1,3,2)
+#define XVID_API                 XVID_MAKE_API(4, 3)
+
+/* Bitstream Version
+ * this will be writen into the bitstream to allow easy detection of xvid
+ * encoder bugs in the decoder, without this it might not possible to
+ * automatically distinquish between a file which has been encoded with an
+ * old & buggy XVID from a file which has been encoded with a bugfree version
+ * see the infamous interlacing bug ...
+ *
+ * this MUST be increased if an encoder bug is fixed, increasing it too often
+ * doesnt hurt but not increasing it could cause difficulty for decoders in the
+ * future
+ */
+#define XVID_BS_VERSION 64 
+
+/*****************************************************************************
+ * error codes
+ ****************************************************************************/
+
+	/*	all functions return values <0 indicate error */
+
+#define XVID_ERR_FAIL		-1		/* general fault */
+#define XVID_ERR_MEMORY		-2		/* memory allocation error */
+#define XVID_ERR_FORMAT		-3		/* file format error */
+#define XVID_ERR_VERSION	-4		/* structure version not supported */
+#define XVID_ERR_END		-5		/* encoder only; end of stream reached */
+
+
+
+/*****************************************************************************
+ * xvid_image_t
+ ****************************************************************************/
+
+/* colorspace values */
+
+#define XVID_CSP_PLANAR   (1<< 0) /* 4:2:0 planar (==I420, except for pointers/strides) */
+#define XVID_CSP_USER	  XVID_CSP_PLANAR
+#define XVID_CSP_I420     (1<< 1) /* 4:2:0 planar */
+#define XVID_CSP_YV12     (1<< 2) /* 4:2:0 planar */
+#define XVID_CSP_YUY2     (1<< 3) /* 4:2:2 packed */
+#define XVID_CSP_UYVY     (1<< 4) /* 4:2:2 packed */
+#define XVID_CSP_YVYU     (1<< 5) /* 4:2:2 packed */
+#define XVID_CSP_RGB      (1<<16) /* 24-bit rgb packed */
+#define XVID_CSP_BGRA     (1<< 6) /* 32-bit bgra packed */
+#define XVID_CSP_ABGR     (1<< 7) /* 32-bit abgr packed */
+#define XVID_CSP_RGBA     (1<< 8) /* 32-bit rgba packed */
+#define XVID_CSP_ARGB     (1<<15) /* 32-bit argb packed */
+#define XVID_CSP_BGR      (1<< 9) /* 24-bit bgr packed */
+#define XVID_CSP_RGB555   (1<<10) /* 16-bit rgb555 packed */
+#define XVID_CSP_RGB565   (1<<11) /* 16-bit rgb565 packed */
+#define XVID_CSP_SLICE    (1<<12) /* decoder only: 4:2:0 planar, per slice rendering */
+#define XVID_CSP_INTERNAL (1<<13) /* decoder only: 4:2:0 planar, returns ptrs to internal buffers */
+#define XVID_CSP_NULL     (1<<14) /* decoder only: dont output anything */
+#define XVID_CSP_VFLIP    (1<<31) /* vertical flip mask */
+
+/* xvid_image_t
+	for non-planar colorspaces use only plane[0] and stride[0]
+	four plane reserved for alpha*/
+typedef struct {
+	int csp;				/* [in] colorspace; or with XVID_CSP_VFLIP to perform vertical flip */
+	void * plane[4];		/* [in] image plane ptrs */
+	int stride[4];			/* [in] image stride; "bytes per row"*/
+} xvid_image_t;
+
+/* video-object-sequence profiles */
+#define XVID_PROFILE_S_L0    0x08 /* simple */
+#define XVID_PROFILE_S_L1    0x01
+#define XVID_PROFILE_S_L2    0x02
+#define XVID_PROFILE_S_L3    0x03
+#define XVID_PROFILE_S_L4a   0x04
+#define XVID_PROFILE_S_L5    0x05
+#define XVID_PROFILE_S_L6    0x06
+#define XVID_PROFILE_ARTS_L1 0x91 /* advanced realtime simple */
+#define XVID_PROFILE_ARTS_L2 0x92
+#define XVID_PROFILE_ARTS_L3 0x93
+#define XVID_PROFILE_ARTS_L4 0x94
+#define XVID_PROFILE_AS_L0   0xf0 /* advanced simple */
+#define XVID_PROFILE_AS_L1   0xf1
+#define XVID_PROFILE_AS_L2   0xf2
+#define XVID_PROFILE_AS_L3   0xf3
+#define XVID_PROFILE_AS_L4   0xf4
+
+/* aspect ratios */
+#define XVID_PAR_11_VGA    1 /* 1:1 vga (square), default if supplied PAR is not a valid value */
+#define XVID_PAR_43_PAL    2 /* 4:3 pal (12:11 625-line) */
+#define XVID_PAR_43_NTSC   3 /* 4:3 ntsc (10:11 525-line) */
+#define XVID_PAR_169_PAL   4 /* 16:9 pal (16:11 625-line) */
+#define XVID_PAR_169_NTSC  5 /* 16:9 ntsc (40:33 525-line) */
+#define XVID_PAR_EXT      15 /* extended par; use par_width, par_height */
+
+/* frame type flags */
+#define XVID_TYPE_VOL     -1 /* decoder only: vol was decoded */
+#define XVID_TYPE_NOTHING  0 /* decoder only (encoder stats): nothing was decoded/encoded */
+#define XVID_TYPE_AUTO     0 /* encoder: automatically determine coding type */
+#define XVID_TYPE_IVOP     1 /* intra frame */
+#define XVID_TYPE_PVOP     2 /* predicted frame */
+#define XVID_TYPE_BVOP     3 /* bidirectionally encoded */
+#define XVID_TYPE_SVOP     4 /* predicted+sprite frame */
+
+
+/*****************************************************************************
+ * xvid_global()
+ ****************************************************************************/
+
+/* cpu_flags definitions (make sure to sync this with cpuid.asm for ia32) */
+
+#define XVID_CPU_FORCE    (1<<31) /* force passed cpu flags */
+#define XVID_CPU_ASM      (1<< 7) /* native assembly */
+/* ARCH_IS_IA32 */
+#define XVID_CPU_MMX      (1<< 0) /*       mmx : pentiumMMX,k6 */
+#define XVID_CPU_MMXEXT   (1<< 1) /*   mmx-ext : pentium2, athlon */
+#define XVID_CPU_SSE      (1<< 2) /*       sse : pentium3, athlonXP */
+#define XVID_CPU_SSE2     (1<< 3) /*      sse2 : pentium4, athlon64 */
+#define XVID_CPU_SSE3     (1<< 8) /*      sse3 : pentium4, athlon64 */
+#define XVID_CPU_SSE41    (1<< 9) /*      sse41: penryn */
+#define XVID_CPU_3DNOW    (1<< 4) /*     3dnow : k6-2 */
+#define XVID_CPU_3DNOWEXT (1<< 5) /* 3dnow-ext : athlon */
+#define XVID_CPU_TSC      (1<< 6) /*       tsc : Pentium */
+/* ARCH_IS_PPC */
+#define XVID_CPU_ALTIVEC  (1<< 0) /* altivec */
+
+
+#define XVID_DEBUG_ERROR     (1<< 0)
+#define XVID_DEBUG_STARTCODE (1<< 1)
+#define XVID_DEBUG_HEADER    (1<< 2)
+#define XVID_DEBUG_TIMECODE  (1<< 3)
+#define XVID_DEBUG_MB        (1<< 4)
+#define XVID_DEBUG_COEFF     (1<< 5)
+#define XVID_DEBUG_MV        (1<< 6)
+#define XVID_DEBUG_RC        (1<< 7)
+#define XVID_DEBUG_DEBUG     (1<<31)
+
+/* XVID_GBL_INIT param1 */
+typedef struct {
+	int version;
+	unsigned int cpu_flags; /* [in:opt] zero = autodetect cpu; XVID_CPU_FORCE|{cpu features} = force cpu features */
+	int debug;     /* [in:opt] debug level */
+} xvid_gbl_init_t;
+
+
+/* XVID_GBL_INFO param1 */
+typedef struct {
+	int version;
+	int actual_version; /* [out] returns the actual xvidcore version */
+	const char * build; /* [out] if !null, points to description of this xvid core build */
+	unsigned int cpu_flags;      /* [out] detected cpu features */
+	int num_threads;    /* [out] detected number of cpus/threads */
+} xvid_gbl_info_t;
+
+
+/* XVID_GBL_CONVERT param1 */
+typedef struct {
+	int version;
+	xvid_image_t input;  /* [in] input image & colorspace */
+	xvid_image_t output; /* [in] output image & colorspace */
+	int width;           /* [in] width */
+	int height;          /* [in] height */
+	int interlacing;     /* [in] interlacing */
+} xvid_gbl_convert_t;
+
+
+#define XVID_GBL_INIT    0 /* initialize xvidcore; must be called before using xvid_decore, or xvid_encore) */
+#define XVID_GBL_INFO    1 /* return some info about xvidcore, and the host computer */
+#define XVID_GBL_CONVERT 2 /* colorspace conversion utility */
+
+extern int xvid_global(void *handle, int opt, void *param1, void *param2);
+
+
+/*****************************************************************************
+ * xvid_decore()
+ ****************************************************************************/
+
+#define XVID_DEC_CREATE  0 /* create decore instance; return 0 on success */
+#define XVID_DEC_DESTROY 1 /* destroy decore instance: return 0 on success */
+#define XVID_DEC_DECODE  2 /* decode a frame: returns number of bytes consumed >= 0 */
+
+extern int xvid_decore(void *handle, int opt, void *param1, void *param2);
+
+/* XVID_DEC_CREATE param 1
+	image width & height as well as FourCC code may be specified 
+	here when known in advance (e.g. being read from container) */
+typedef struct {
+	int version;
+	int width;      /* [in:opt] image width */
+	int height;     /* [in:opt] image width */
+	void * handle;  /* [out]    decore context handle */
+/* ------- v1.3.x ------- */
+	int fourcc;     /* [in:opt] fourcc of the input video */
+	int num_threads;/* [in:opt] number of threads to use in decoder */
+} xvid_dec_create_t;
+
+
+/* XVID_DEC_DECODE param1 */
+/* general flags */
+#define XVID_LOWDELAY      (1<<0) /* lowdelay mode  */
+#define XVID_DISCONTINUITY (1<<1) /* indicates break in stream */
+#define XVID_DEBLOCKY      (1<<2) /* perform luma deblocking */
+#define XVID_DEBLOCKUV     (1<<3) /* perform chroma deblocking */
+#define XVID_FILMEFFECT    (1<<4) /* adds film grain */
+#define XVID_DERINGUV      (1<<5) /* perform chroma deringing, requires deblocking to work */
+#define XVID_DERINGY       (1<<6) /* perform luma deringing, requires deblocking to work */
+
+#define XVID_DEC_FAST      (1<<29) /* disable postprocessing to decrease cpu usage *todo* */
+#define XVID_DEC_DROP      (1<<30) /* drop bframes to decrease cpu usage *todo* */
+#define XVID_DEC_PREROLL   (1<<31) /* decode as fast as you can, don't even show output *todo* */
+
+typedef struct {
+	int version;
+	int general;         /* [in:opt] general flags */
+	void *bitstream;     /* [in]     bitstream (read from)*/
+	int length;          /* [in]     bitstream length */
+	xvid_image_t output; /* [in]     output image (written to) */
+/* ------- v1.1.x ------- */
+	int brightness;		 /* [in]	 brightness offset (0=none) */
+} xvid_dec_frame_t;
+
+
+/* XVID_DEC_DECODE param2 :: optional */
+typedef struct
+{
+	int version;
+
+	int type;                   /* [out] output data type */
+	union {
+		struct { /* type>0 {XVID_TYPE_IVOP,XVID_TYPE_PVOP,XVID_TYPE_BVOP,XVID_TYPE_SVOP} */
+			int general;        /* [out] flags */
+			int time_base;      /* [out] time base */
+			int time_increment; /* [out] time increment */
+
+			/* XXX: external deblocking stuff */
+			int * qscale;	    /* [out] pointer to quantizer table */
+			int qscale_stride;  /* [out] quantizer scale stride */
+
+		} vop;
+		struct {	/* XVID_TYPE_VOL */
+			int general;        /* [out] flags */
+			int width;          /* [out] width */
+			int height;         /* [out] height */
+			int par;            /* [out] pixel aspect ratio (refer to XVID_PAR_xxx above) */
+			int par_width;      /* [out] aspect ratio width  [1..255] */
+			int par_height;     /* [out] aspect ratio height [1..255] */
+		} vol;
+	} data;
+} xvid_dec_stats_t;
+
+#define XVID_ZONE_QUANT  (1<<0)
+#define XVID_ZONE_WEIGHT (1<<1)
+
+typedef struct
+{
+	int frame;
+	int mode;
+	int increment;
+	int base;
+} xvid_enc_zone_t;
+
+
+/*----------------------------------------------------------------------------
+ * xvid_enc_stats_t structure
+ *
+ * Used in:
+ *  - xvid_plg_data_t structure
+ *  - optional parameter in xvid_encore() function
+ *
+ * .coding_type = XVID_TYPE_NOTHING if the stats are not given
+ *--------------------------------------------------------------------------*/
+
+typedef struct {
+	int version;
+
+	/* encoding parameters */
+	int type;      /* [out] coding type */
+	int quant;     /* [out] frame quantizer */
+	int vol_flags; /* [out] vol flags (see above) */
+	int vop_flags; /* [out] vop flags (see above) */
+
+	/* bitrate */
+	int length;    /* [out] frame length */
+
+	int hlength;   /* [out] header length (bytes) */
+	int kblks;     /* [out] number of blocks compressed as Intra */
+	int mblks;     /* [out] number of blocks compressed as Inter */
+	int ublks;     /* [out] number of blocks marked as not_coded */
+
+	int sse_y;     /* [out] Y plane's sse */
+	int sse_u;     /* [out] U plane's sse */
+	int sse_v;     /* [out] V plane's sse */
+} xvid_enc_stats_t;
+
+/*****************************************************************************
+  xvid plugin system -- internals
+
+  xvidcore will call XVID_PLG_INFO and XVID_PLG_CREATE during XVID_ENC_CREATE
+  before encoding each frame xvidcore will call XVID_PLG_BEFORE
+  after encoding each frame xvidcore will call XVID_PLG_AFTER
+  xvidcore will call XVID_PLG_DESTROY during XVID_ENC_DESTROY
+ ****************************************************************************/
+
+
+#define XVID_PLG_CREATE  (1<<0)
+#define XVID_PLG_DESTROY (1<<1)
+#define XVID_PLG_INFO    (1<<2)
+#define XVID_PLG_BEFORE  (1<<3)
+#define XVID_PLG_FRAME   (1<<4)
+#define XVID_PLG_AFTER   (1<<5)
+
+/* xvid_plg_info_t.flags */
+#define XVID_REQORIGINAL (1<<0) /* plugin requires a copy of the original (uncompressed) image */
+#define XVID_REQPSNR     (1<<1) /* plugin requires psnr between the uncompressed and compressed image*/
+#define XVID_REQDQUANTS  (1<<2) /* plugin requires access to the dquant table */
+#define XVID_REQLAMBDA   (1<<3) /* plugin requires access to the lambda table */
+
+typedef struct
+{
+	int version;
+	int flags;   /* [in:opt] plugin flags */
+} xvid_plg_info_t;
+
+
+typedef struct
+{
+	int version;
+
+	int num_zones;           /* [out] */
+	xvid_enc_zone_t * zones; /* [out] */
+
+	int width;               /* [out] */
+	int height;              /* [out] */
+	int mb_width;            /* [out] */
+	int mb_height;           /* [out] */
+	int fincr;               /* [out] */
+	int fbase;               /* [out] */
+
+	void * param;            /* [out] */
+} xvid_plg_create_t;
+
+
+typedef struct
+{
+	int version;
+
+	int num_frames; /* [out] total frame encoded */
+} xvid_plg_destroy_t;
+
+typedef struct
+{
+	int version;
+
+	xvid_enc_zone_t * zone; /* [out] current zone */
+
+	int width;              /* [out] */
+	int height;             /* [out] */
+	int mb_width;           /* [out] */
+	int mb_height;          /* [out] */
+	int fincr;              /* [out] */
+	int fbase;              /* [out] */
+
+	int min_quant[3];       /* [out] */
+	int max_quant[3];       /* [out] */
+
+	xvid_image_t reference; /* [out] -> [out] */
+	xvid_image_t current;   /* [out] -> [in,out] */
+	xvid_image_t original;  /* [out] after: points the original (uncompressed) copy of the current frame */
+	int frame_num;          /* [out] frame number */
+
+	int type;               /* [in,out] */
+	int quant;              /* [in,out] */
+
+	int * dquant;           /* [in,out]	pointer to diff quantizer table */
+	int dquant_stride;      /* [in,out]	diff quantizer stride */
+
+	int vop_flags;          /* [in,out] */
+	int vol_flags;          /* [in,out] */
+	int motion_flags;       /* [in,out] */
+
+	/* Lambda table for HVSPlugins */
+	float * lambda;         /* [in,out] six floats for each macroblock. read, multiply, write back */
+
+/* Deprecated, use the stats field instead.
+ * Will disapear before 1.0 */
+	int length;             /* [out] after: length of encoded frame */
+	int kblks;              /* [out] number of blocks compressed as Intra */
+	int mblks;              /* [out] number of blocks compressed as Inter */
+	int ublks;              /* [out] number of blocks marked not_coded */
+	int sse_y;              /* [out] Y plane's sse */
+	int sse_u;              /* [out] U plane's sse */
+	int sse_v;              /* [out] V plane's sse */
+/* End of duplicated data, kept only for binary compatibility */
+
+	int bquant_ratio;       /* [in] */
+	int bquant_offset;      /* [in] */
+
+	xvid_enc_stats_t stats; /* [out] frame statistics */
+} xvid_plg_data_t;
+
+/*****************************************************************************
+  xvid plugin system -- external
+
+  the application passes xvid an array of "xvid_plugin_t" at XVID_ENC_CREATE. the array
+  indicates the plugin function pointer and plugin-specific data.
+  xvidcore handles the rest. example:
+
+  xvid_enc_create_t create;
+  xvid_enc_plugin_t plugins[2];
+
+  plugins[0].func = xvid_psnr_func;
+  plugins[0].param = NULL;
+  plugins[1].func = xvid_cbr_func;
+  plugins[1].param = &cbr_data;
+
+  create.num_plugins = 2;
+  create.plugins = plugins;
+
+ ****************************************************************************/
+
+typedef int (xvid_plugin_func)(void * handle, int opt, void * param1, void * param2);
+
+typedef struct
+{
+	xvid_plugin_func * func;
+	void * param;
+} xvid_enc_plugin_t;
+
+
+extern xvid_plugin_func xvid_plugin_single;   /* single-pass rate control */
+extern xvid_plugin_func xvid_plugin_2pass1;   /* two-pass rate control: first pass */
+extern xvid_plugin_func xvid_plugin_2pass2;   /* two-pass rate control: second pass */
+
+extern xvid_plugin_func xvid_plugin_lumimasking;  /* lumimasking */
+
+extern xvid_plugin_func xvid_plugin_psnr;	/* write psnr values to stdout */
+extern xvid_plugin_func xvid_plugin_dump;	/* dump before and after yuvpgms */
+
+extern xvid_plugin_func xvid_plugin_ssim;	    /*write ssim values to stdout*/
+extern xvid_plugin_func xvid_plugin_psnrhvsm;	/*write psnrhvsm values to stdout*/
+
+
+/* single pass rate control
+ * CBR and Constant quantizer modes */
+typedef struct
+{
+	int version;
+
+	int bitrate;               /* [in] bits per second */
+	int reaction_delay_factor; /* [in] */
+	int averaging_period;      /* [in] */
+	int buffer;                /* [in] */
+} xvid_plugin_single_t;
+
+
+typedef struct {
+	int version;
+
+	char * filename;
+} xvid_plugin_2pass1_t;
+
+
+#define XVID_PAYBACK_BIAS 0 /* payback with bias */
+#define XVID_PAYBACK_PROP 1 /* payback proportionally */
+
+typedef struct {
+	int version;
+
+	int bitrate;                  /* [in] target bitrate (bits per second) */
+	char * filename;              /* [in] first pass stats filename */
+
+	int keyframe_boost;           /* [in] keyframe boost percentage: [0..100] */
+	int curve_compression_high;   /* [in] percentage of compression performed on the high part of the curve (above average) */
+	int curve_compression_low;    /* [in] percentage of compression performed on the low  part of the curve (below average) */
+	int overflow_control_strength;/* [in] Payback delay expressed in number of frames */
+	int max_overflow_improvement; /* [in] percentage of allowed range for a frame that gets bigger because of overflow bonus */
+	int max_overflow_degradation; /* [in] percentage of allowed range for a frame that gets smaller because of overflow penalty */
+
+	int kfreduction;              /* [in] maximum bitrate reduction applied to an iframe under the kfthreshold distance limit */
+	int kfthreshold;              /* [in] if an iframe is closer to the next iframe than this distance, a quantity of bits
+								   *      is substracted from its bit allocation. The reduction is computed as multiples of
+								   *      kfreduction/kthreshold. It reaches kfreduction when the distance == kfthreshold,
+								   *      0 for 1<distance<kfthreshold */
+
+	int container_frame_overhead; /* [in] How many bytes the controller has to compensate per frame due to container format overhead */
+
+/* ------- v1.1.x ------- */
+	int vbv_size;                 /* [in] buffer size (bits) If this is zero, VBV check is disabled.*/
+	int vbv_initial;              /* [in] initial buffer occupancy (bits) */
+	int vbv_maxrate;              /* [in] max processing bitrate (bits per second) */
+	int vbv_peakrate;             /* [in:opt] max average bitrate over 1 second (bits per second).
+								   *          This is used for diagnostics only and won't affect the actual peak bitrate.
+								   *          This is not a problem as long as vbv_peakrate > vbv_size + vbv_maxrate which
+								   *          guarantees that vbv_peakrate won't be exceeded. */
+}xvid_plugin_2pass2_t;
+
+
+typedef struct{
+	/*stat output*/
+	int b_printstat;
+	char* stat_path;
+	
+	/*visualize*/
+	int b_visualize;
+
+	/*accuracy 0 very accurate 4 very fast*/
+	int acc; 
+
+    int cpu_flags; /* XVID_CPU_XXX flags */
+
+} xvid_plugin_ssim_t;
+
+typedef struct {
+        int version;
+
+        int method;      /* [in] masking method to apply. 0 for luminance masking, 1 for variance masking */
+} xvid_plugin_lumimasking_t;
+
+/*****************************************************************************
+ *                             ENCODER API
+ ****************************************************************************/
+
+/*----------------------------------------------------------------------------
+ * Encoder operations
+ *--------------------------------------------------------------------------*/
+
+#define XVID_ENC_CREATE  0 /* create encoder instance; returns 0 on success */
+#define XVID_ENC_DESTROY 1 /* destroy encoder instance; returns 0 on success */
+#define XVID_ENC_ENCODE  2 /* encode a frame: returns number of ouput bytes
+                            * 0 means this frame should not be written (ie. encoder lag) */
+
+
+/*----------------------------------------------------------------------------
+ * Encoder entry point
+ *--------------------------------------------------------------------------*/
+
+extern int xvid_encore(void *handle, int opt, void *param1, void *param2);
+
+/* Quick API reference
+ *
+ * XVID_ENC_CREATE operation
+ *  - handle: ignored
+ *  - opt: XVID_ENC_CREATE
+ *  - param1: address of a xvid_enc_create_t structure
+ *  - param2: ignored
+ *
+ * XVID_ENC_ENCODE operation
+ *  - handle: an instance returned by a CREATE op
+ *  - opt: XVID_ENC_ENCODE
+ *  - param1: address of a xvid_enc_frame_t structure
+ *  - param2: address of a xvid_enc_stats_t structure (optional)
+ *            its return value is asynchronous to what is written to the buffer
+ *            depending on the delay introduced by bvop use. It's display
+ *            ordered.
+ *
+ * XVID_ENC_DESTROY operation
+ *  - handle: an instance returned by a CREATE op
+ *  - opt: XVID_ENC_DESTROY
+ *  - param1: ignored
+ *  - param2: ignored
+ */
+
+
+/*----------------------------------------------------------------------------
+ * "Global" flags
+ *
+ * These flags are used for xvid_enc_create_t->global field during instance
+ * creation (operation XVID_ENC_CREATE)
+ *--------------------------------------------------------------------------*/
+
+#define XVID_GLOBAL_PACKED            (1<<0) /* packed bitstream */
+#define XVID_GLOBAL_CLOSED_GOP        (1<<1) /* closed_gop:	was DX50BVOP dx50 bvop compatibility */
+#define XVID_GLOBAL_EXTRASTATS_ENABLE (1<<2)
+#if 0
+#define XVID_GLOBAL_VOL_AT_IVOP       (1<<3) /* write vol at every ivop: WIN32/divx compatibility */
+#define XVID_GLOBAL_FORCE_VOL         (1<<4) /* when vol-based parameters are changed, insert an ivop NOT recommended */
+#endif
+#define XVID_GLOBAL_DIVX5_USERDATA    (1<<5) /* write divx5 userdata string 
+                                                this is implied if XVID_GLOBAL_PACKED is set */
+
+/*----------------------------------------------------------------------------
+ * "VOL" flags
+ *
+ * These flags are used for xvid_enc_frame_t->vol_flags field during frame
+ * encoding (operation XVID_ENC_ENCODE)
+ *--------------------------------------------------------------------------*/
+
+#define XVID_VOL_MPEGQUANT      (1<<0) /* enable MPEG type quantization */
+#define XVID_VOL_EXTRASTATS     (1<<1) /* enable plane sse stats */
+#define XVID_VOL_QUARTERPEL     (1<<2) /* enable quarterpel: frames will encoded as quarterpel */
+#define XVID_VOL_GMC            (1<<3) /* enable GMC; frames will be checked for gmc suitability */
+#define XVID_VOL_REDUCED_ENABLE (1<<4) /* enable reduced resolution vops: frames will be checked for rrv suitability */
+									   /* NOTE:  the reduced resolution feature is not supported anymore. This flag will have no effect! */
+#define XVID_VOL_INTERLACING    (1<<5) /* enable interlaced encoding */
+
+
+/*----------------------------------------------------------------------------
+ * "VOP" flags
+ *
+ * These flags are used for xvid_enc_frame_t->vop_flags field during frame
+ * encoding (operation XVID_ENC_ENCODE)
+ *--------------------------------------------------------------------------*/
+
+/* Always valid */
+#define XVID_VOP_DEBUG                (1<< 0) /* print debug messages in frames */
+#define XVID_VOP_HALFPEL              (1<< 1) /* use halfpel interpolation */
+#define XVID_VOP_INTER4V              (1<< 2) /* use 4 motion vectors per MB */
+#define XVID_VOP_TRELLISQUANT         (1<< 3) /* use trellis based R-D "optimal" quantization */
+#define XVID_VOP_CHROMAOPT            (1<< 4) /* enable chroma optimization pre-filter */
+#define XVID_VOP_CARTOON              (1<< 5) /* use 'cartoon mode' */
+#define XVID_VOP_GREYSCALE            (1<< 6) /* enable greyscale only mode (even for  color input material chroma is ignored) */
+#define XVID_VOP_HQACPRED             (1<< 7) /* high quality ac prediction */
+#define XVID_VOP_MODEDECISION_RD      (1<< 8) /* enable DCT-ME and use it for mode decision */
+#define XVID_VOP_FAST_MODEDECISION_RD (1<<12) /* use simplified R-D mode decision */
+#define XVID_VOP_RD_BVOP              (1<<13) /* enable rate-distortion mode decision in b-frames */
+#define XVID_VOP_RD_PSNRHVSM          (1<<14) /* use PSNR-HVS-M as metric for rate-distortion optimizations */
+
+/* Only valid for vol_flags|=XVID_VOL_INTERLACING */
+#define XVID_VOP_TOPFIELDFIRST        (1<< 9) /* set top-field-first flag  */
+#define XVID_VOP_ALTERNATESCAN        (1<<10) /* set alternate vertical scan flag */
+
+/* only valid for vol_flags|=XVID_VOL_REDUCED_ENABLED */
+#define XVID_VOP_REDUCED              (1<<11) /* reduced resolution vop */
+											  /* NOTE: reduced resolution feature is not supported anymore. This flag will have no effect! */
+
+/*----------------------------------------------------------------------------
+ * "Motion" flags
+ *
+ * These flags are used for xvid_enc_frame_t->motion field during frame
+ * encoding (operation XVID_ENC_ENCODE)
+ *--------------------------------------------------------------------------*/
+
+/* Motion Estimation Search Patterns */
+#define XVID_ME_ADVANCEDDIAMOND16     (1<< 0) /* use advdiamonds instead of diamonds as search pattern */
+#define XVID_ME_ADVANCEDDIAMOND8      (1<< 1) /* use advdiamond for XVID_ME_EXTSEARCH8 */
+#define XVID_ME_USESQUARES16          (1<< 2) /* use squares instead of diamonds as search pattern */
+#define XVID_ME_USESQUARES8           (1<< 3) /* use square for XVID_ME_EXTSEARCH8 */
+
+/* SAD operator based flags */
+#define XVID_ME_HALFPELREFINE16       (1<< 4)
+#define XVID_ME_HALFPELREFINE8        (1<< 6)
+#define XVID_ME_QUARTERPELREFINE16    (1<< 7)
+#define XVID_ME_QUARTERPELREFINE8     (1<< 8)
+#define XVID_ME_GME_REFINE            (1<< 9)
+#define XVID_ME_EXTSEARCH16           (1<<10) /* extend PMV by more searches */
+#define XVID_ME_EXTSEARCH8            (1<<11) /* use diamond/square for extended 8x8 search */
+#define XVID_ME_CHROMA_PVOP           (1<<12) /* also use chroma for P_VOP/S_VOP ME */
+#define XVID_ME_CHROMA_BVOP           (1<<13) /* also use chroma for B_VOP ME */
+#define XVID_ME_FASTREFINE16          (1<<25) /* use low-complexity refinement functions */
+#define XVID_ME_FASTREFINE8           (1<<29) /* low-complexity 8x8 sub-block refinement */
+
+/* Rate Distortion based flags
+ * Valid when XVID_VOP_MODEDECISION_RD is enabled */
+#define XVID_ME_HALFPELREFINE16_RD    (1<<14) /* perform RD-based halfpel refinement */
+#define XVID_ME_HALFPELREFINE8_RD     (1<<15) /* perform RD-based halfpel refinement for 8x8 mode */
+#define XVID_ME_QUARTERPELREFINE16_RD (1<<16) /* perform RD-based qpel refinement */
+#define XVID_ME_QUARTERPELREFINE8_RD  (1<<17) /* perform RD-based qpel refinement for 8x8 mode */
+#define XVID_ME_EXTSEARCH_RD          (1<<18) /* perform RD-based search using square pattern enable XVID_ME_EXTSEARCH8 to do this in 8x8 search as well */
+#define XVID_ME_CHECKPREDICTION_RD    (1<<19) /* always check vector equal to prediction */
+
+/* Other */
+#define XVID_ME_DETECT_STATIC_MOTION  (1<<24) /* speed-up ME by detecting stationary scenes */
+#define XVID_ME_SKIP_DELTASEARCH      (1<<26) /* speed-up by skipping b-frame delta search */
+#define XVID_ME_FAST_MODEINTERPOLATE  (1<<27) /* speed-up by partly skipping interpolate mode */
+#define XVID_ME_BFRAME_EARLYSTOP      (1<<28) /* speed-up by early exiting b-search */
+
+/* Unused */
+#define XVID_ME_UNRESTRICTED16        (1<<20) /* unrestricted ME, not implemented */
+#define XVID_ME_OVERLAPPING16         (1<<21) /* overlapping ME, not implemented */
+#define XVID_ME_UNRESTRICTED8         (1<<22) /* unrestricted ME, not implemented */
+#define XVID_ME_OVERLAPPING8          (1<<23) /* overlapping ME, not implemented */
+
+
+/*----------------------------------------------------------------------------
+ * xvid_enc_create_t structure definition
+ *
+ * This structure is passed as param1 during an instance creation (operation
+ * XVID_ENC_CREATE)
+ *--------------------------------------------------------------------------*/
+
+typedef struct {
+	int version;
+
+	int profile;                 /* [in] profile@level; refer to XVID_PROFILE_xxx */
+	int width;                   /* [in] frame dimensions; width, pixel units */
+	int height;                  /* [in] frame dimensions; height, pixel units */
+
+	int num_zones;               /* [in:opt] number of bitrate zones */
+	xvid_enc_zone_t * zones;     /*          ^^ zone array */
+
+	int num_plugins;             /* [in:opt] number of plugins */
+	xvid_enc_plugin_t * plugins; /*          ^^ plugin array */
+
+	int num_threads;             /* [in:opt] number of threads to use in encoder */
+	int max_bframes;             /* [in:opt] max sequential bframes (0=disable bframes) */
+
+	int global;                  /* [in:opt] global flags; controls encoding behavior */
+
+	/* --- vol-based stuff; included here for convenience */
+	int fincr;                   /* [in:opt] framerate increment; set to zero for variable framerate */
+	int fbase;                   /* [in] framerate base frame_duration = fincr/fbase seconds*/
+    /* ---------------------------------------------- */
+
+	/* --- vop-based; included here for convenience */
+	int max_key_interval;        /* [in:opt] the maximum interval between key frames */
+
+	int frame_drop_ratio;        /* [in:opt] frame dropping: 0=drop none... 100=drop all */
+
+	int bquant_ratio;            /* [in:opt] bframe quantizer multipier/offeset; used to decide bframes quant when bquant==-1 */
+	int bquant_offset;           /* bquant = (avg(past_ref_quant,future_ref_quant)*bquant_ratio + bquant_offset) / 100 */
+
+	int min_quant[3];            /* [in:opt] */
+	int max_quant[3];            /* [in:opt] */
+	/* ---------------------------------------------- */
+
+	void *handle;                /* [out] encoder instance handle */
+
+	/* ------- v1.3.x ------- */
+	int start_frame_num;         /* [in:opt] frame number of start frame relative to zones definitions. allows to encode sub-sequences */
+	int num_slices;              /* [in:opt] number of slices to code for each frame */
+} xvid_enc_create_t;
+
+
+/*----------------------------------------------------------------------------
+ * xvid_enc_frame_t structure definition
+ *
+ * This structure is passed as param1 during a frame encoding (operation
+ * XVID_ENC_ENCODE)
+ *--------------------------------------------------------------------------*/
+
+/* out value for the frame structure->type field
+ * unlike stats output in param2, this field is not asynchronous and tells
+ * the client app, if the frame written into the stream buffer is an ivop
+ * usually used for indexing purpose in the container */
+#define XVID_KEYFRAME (1<<1)
+
+/* The structure */
+typedef struct {
+	int version;
+
+	/* VOL related stuff
+	 * unless XVID_FORCEVOL is set, the encoder will not react to any changes
+	 * here until the next VOL (keyframe). */
+
+	int vol_flags;                     /* [in] vol flags */
+	unsigned char *quant_intra_matrix; /* [in:opt] custom intra qmatrix */
+	unsigned char *quant_inter_matrix; /* [in:opt] custom inter qmatrix */
+
+	int par;                           /* [in:opt] pixel aspect ratio (refer to XVID_PAR_xxx above) */
+	int par_width;                     /* [in:opt] aspect ratio width */
+	int par_height;                    /* [in:opt] aspect ratio height */
+
+	/* Other fields that can change on a frame base */
+
+	int fincr;                         /* [in:opt] framerate increment, for variable framerate only */
+	int vop_flags;                     /* [in] (general)vop-based flags */
+	int motion;                        /* [in] ME options */
+
+	xvid_image_t input;                /* [in] input image (read from) */
+
+	int type;                          /* [in:opt] coding type */
+	int quant;                         /* [in] frame quantizer; if <=0, automatic (ratecontrol) */
+	int bframe_threshold;
+
+	void *bitstream;                   /* [in:opt] bitstream ptr (written to)*/
+	int length;                        /* [in:opt] bitstream length (bytes) */
+
+	int out_flags;                     /* [out] bitstream output flags */
+} xvid_enc_frame_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
